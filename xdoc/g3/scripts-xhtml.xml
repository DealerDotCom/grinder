<?xml version="1.0" encoding="UTF-8"?>

<html>
<body>

<em>More material to come! For now see the <a
href="../script-javadoc/index.html" target="_top_">script API</a> and
the <a href="script-gallery.html">script gallery</a>.</em>

<h1>Scripts</h1>

<h2>Jython and Python</h2>

<p>The Grinder 3 scripting engine is Jython - the Java implementation
of Python. Python is powerful, popular and easy on the eye. If you've
never seen any Python before, don't panic. Take a look at the <a
href="script-gallery">script gallery</a> to get a taste of what its
like. There are plenty of resources on the web, here are a few to get
you started:</p>

<blockquote>
<table>
<tr><td><a href="http://www.jython.org">The Jython home page</a></td></tr>
<tr><td><a href="http://www.python.org">The Python language website</a></td></tr>
</table>
</blockquote>

<p>I recommend the <a
href="http://www.amazon.com/exec/obidos/tg/detail/-/0596002475/qid%3D1044795121/103-7145719-3118225">Jython
Essentials</a> book; you can read the <a
href="http://www.oreilly.com/catalog/jythoness/chapter/ch01.html">introductory
chapter</a> for free.
</p>

<h2>Scripting for The Grinder</h2>

<h3>Script structure</h3>

<p>Scripts must conform to a few conventions in order to work with The
Grinder framework. I'll lay the rules out in fairly dry terms before
proceeding with an example. Don't worry if this makes no sense to you
at first, the examples are much easier to comprehend.</p>

<ol>
<li><h4>Scripts must define a class called <code>TestRunner</code></h4>

<p>When a worker process starts up it runs the test script once. The
test script must define a class thing called
<em><code>TestRunner</code></em>. When it starts, the Grinder engine
creates an instance of <code>TestRunner</code> for each worker thread
and assigns the instance to the worker thread. A thread's TestRunner
instance can be used to store information specific to that thread.</p>
</li>

<p><em>(Although strongly recommended, strictly
<code>TestRunner</code> doesn't need to be a class. See the <a
href="./script-gallery.html#hello-world-functions">Hello World with
Functions</a> example.)</em></p>

<li><h4>The <code>TestRunner</code> instance must be callable</h4>

<p>Each worker thread performs a number of <em>runs</em> of the test
script, as configured by the <a
href="./getting-started.html#grinder.runs"/> property. For each run,
the worker thread calls its TestRunner instance.</p></li>

<li><h4>The test script can access services through the
<code>grinder</code> object</h4>

<p>The engine makes an object called <code>grinder</code> available to
the script. This is an instance of the <a
href="../script-javadoc/net/grinder/script/ScriptContext.html"
target="_top_">ScriptContext</a> class and provides access to context
information (such as the worker thread ID) and services (such as
logging).</p></li>
</ol>


<h3>Canonical test script structure</h3>

<p>This is an example of a script that conforms to the rules above. It
doesn't do very much - every run will log <em>Hello World</em> to the
output log.</p>

<blockquote>
<pre><span class="comment"># An instance of this class is created for every thread.</span>
<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="comment"># This method is called for every run.
</span>    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        <span class="comment"># Per thread scripting goes here.
</span>        grinder.logger.output(&quot;<span class="string">Hello World</span>&quot;)
</pre>
</blockquote>

<h2>Tests</h2>

<p>Although our simple test script can be used with The Grinder
framework and can easily be started in many threads on many machines,
it does record any statistics. For this we need to create some tests.
A <a href="../script-javadoc/net/grinder/script/Test.html"
target="_top_">Test</a> has a unique test number and description. If
you are using the <a href="./console.html">console</a>, it will
automatically update to display new tests as they are created.</p>

<p>Let's add a <code>Test</code> to our script.</p>

<blockquote>
<pre>
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test

<span class="comment"># A shorter alias for the grinder.logger.output() method.
</span>log = grinder.logger.output

<span class="comment"># Create a Test with a test number and a description.
</span>test1 = Test(1, &quot;<span class="string">Log method</span>&quot;)

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        log(&quot;<span class="string">Hello World</span>&quot;)
</pre>
</blockquote>

<p>Here we have created a single <code>Test</code> with the test
number <em>1</em> and the description <em>Log method</em>. Note how
must import the <code>Test</code> class in a similar manner to Java.
We've also take the opportunity to add a shorter alias for the
<code>grinder.logger.output</code> method.</p>

<p>So the console knows about the test, but we're still not using it
to record anything. To do that we must instrument the thing we want to
record. For this example let's record how long our <code>log</code>
method takes. To instrument the <code>log</code> method we use our
<code>Test</code> to wrap it with a proxy <em>wrapper</em>. The
wrapper object looks exactly like the <code>log</code> method and can
be called in the same manner. If we call the wrapper the call will be
delegated through to the <code>log</code> method but additionally the
time taken to do the call and the number of calls will be recorded and
reported to the console.</p>

<blockquote>
<pre><span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test

log = grinder.logger.output

test1 = Test(1, &quot;<span class="string">Log method</span>&quot;)

<span class="comment"># Wrap the log() method with our Test and call the result logWrapper.
</span>logWrapper = test1.wrap(log)

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        logWrapper(&quot;<span class="string">Hello World</span>&quot;)
</pre>
</blockquote>

<p>This is a fully functional test script that works within The
Grinder framework and reports results to the console.</p>

<p>You're not restricted to wrapping method calls. In fact, its more
common to wrap objects. Here's an example using The Grinder's <a
href="./http-plugin.html">HTTP plug-in</a>.</p>

<blockquote>
<pre><span class="comment"># A simple example using the HTTP plugin that shows the retrieval of a
# single page via HTTP.
</span>
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test
<span class="keyword">from</span> net.grinder.plugin.http <span class="keyword">import</span> HTTPRequest

test1 = Test(1, &quot;<span class="string">Request resource</span>&quot;)
request1 = test1.wrap(HTTPRequest())

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        result = request1.GET(&quot;<span class="string">http://localhost:7001/</span>&quot;)
</pre>
</blockquote>

<h2>The Grinder script API</h2>

<p>With what you've seen already you have the full power of Jython at
your finger tips. You can use practically <em>any</em> Java or Python
code in your test scripts.</p>

<p>The Grinder <a href="../script-javadoc/index.html"
target="_top_">script API</a> can be used to access services from The
Grinder.</p>

<h3>The Grinder statistics API</h3>


<p class="draft-warning">Draft material follows</p>

<h2>The Jython distribution and installation</h2>

<p>The Grinder is shipped with a version of Jython but does not
package the Jython distribution of the standard Python library. If you
want to use the standard library, or if you want to use a different
version of Jython, obtain and install Jython and add the
installation's <code>jython.jar</code> to the start of the
<code>CLASSPATH</code> used to launch The Grinder.</p>

<p>Jython picks up user and site preferences from several sources (see
<a
href="http://www.jython.org/docs/registry.html">http://www.jython.org/docs/registry.html</a>).
A side effect of adding the installed <code>jython.jar</code> to the
start of the <code>CLASSPATH</code> is that <code>python.home</code>
can be correctly determined and the installed registry file will be
used.</p>

<p>A useful thing that you can set in the registry is
<code>python.cachedir</code>. This specifies a working directory which
Jython uses to store byte compiled python code. If you do not have
your own installed version of Jython in the <code>CLASSPATH</code>,
the working directory will be created in the directory which you run
The Grinder. This is fine for most casual users; if you are are
terribly worried about preserving disk space, read the information on
the Jython site.</p>


</body>
</html>
