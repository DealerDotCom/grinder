<?xml version="1.0" encoding="UTF-8"?>

<html>
<body>

<h1>Scripts</h1>

<p><em>This page describes The Grinder 3 scripting API. If you've used
The Grinder 2 for HTTP testing and you're not a programmer, you might
be a bit daunted. Don't worry, its just as easy to record and replay
HTTP scripts with The Grinder 3.</em></p>

<h2>Jython and Python</h2>

<p>The Grinder 3 scripting engine is Jython - the Java implementation
of Python. Python is powerful, popular and easy on the eye. If you've
never seen any Python before, don't panic. Take a look at the <a
href="script-gallery">script gallery</a> to get a taste of what its
like. There are plenty of resources on the web, here are a few of them
to get you started:</p>

<blockquote>
<table>
<tr><td><a href="http://www.jython.org">The Jython home page</a></td></tr>
<tr><td><a href="http://www.python.org">The Python language web site</a></td></tr>
</table>
</blockquote>

<p>I recommend the <a
href="http://www.amazon.com/exec/obidos/tg/detail/-/0596002475/qid%3D1044795121/103-7145719-3118225">Jython
Essentials</a> book; you can read the <a
href="http://www.oreilly.com/catalog/jythoness/chapter/ch01.html">introductory
chapter</a> for free.
</p>

<h2>Scripting for The Grinder</h2>

<h3>Script structure</h3>

<p>Scripts must conform to a few conventions in order to work with The
Grinder framework. I'll lay the rules out in fairly dry terms before
proceeding with an example. Don't worry if this makes no sense to you
at first, the examples are much easier to comprehend.</p>

<ol>
<li><h4>Scripts must define a class called <code>TestRunner</code></h4>

<p>When a worker process starts up it runs the test script once. The
test script must define a class thing called <code>TestRunner</code>.
The Grinder engine then creates an instance of <code>TestRunner</code>
for each worker thread. A thread's TestRunner instance can be used to
store information specific to that thread.</p>
</li>

<p><em>(Although strongly recommended, strictly
<code>TestRunner</code> doesn't need to be a class. See the <a
href="./script-gallery.html#hello-world-functions">Hello World with
Functions</a> example.)</em></p>

<li><h4>The <code>TestRunner</code> instance must be callable</h4>

<p>A Python object is callable if it defines a <code>__call__</code>
method. Each worker thread performs a number of <em>runs</em> of the
test script, as configured by the property <a
href="./getting-started.html#grinder.runs">grinder.runs</a>. For each
run, the worker thread calls its <code>TestRunner</code>; thus the
<code>__call__</code> method can be thought of as the definition of a
run.</p></li>

<li><h4>The test script can access services through the
<code>grinder</code> object</h4>

<p>The engine makes an object called <code>grinder</code> available to
the script. This is an instance of the <code><a
href="../script-javadoc/net/grinder/script/ScriptContext.html">ScriptContext</a></code>
class and provides access to context information (such as the worker
thread ID) and services (such as logging and statistics).</p></li>
</ol>


<h3>Canonical test script structure</h3>

<p>This is an example of a script that conforms to the rules above. It
doesn't do very much - every run will log <em>Hello World</em> to the
output log.</p>

<blockquote>
<pre><span class="comment"># An instance of this class is created for every thread.</span>
<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="comment"># This method is called for every run.
</span>    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        <span class="comment"># Per thread scripting goes here.
</span>        grinder.logger.output(&quot;<span class="string">Hello World</span>&quot;)
</pre>
</blockquote>

<h2><a name="tests">Tests</a></h2>

<p>Although our simple test script can be used with The Grinder
framework and can easily be started in many times in many worker
processes on many machines, it doesn't report any statistics. For this
we need to create some tests. A <a
href="../script-javadoc/net/grinder/script/Test.html">Test</a> has a
unique test number and description. If you are using the <a
href="./console.html">console</a>, it will automatically update to
display new <code>Test</code>s as they are created.</p>

<p>Let's add a <code>Test</code> to our script.</p>

<blockquote>
<pre>
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test

<span class="comment"># A shorter alias for the grinder.logger.output() method.
</span>log = grinder.logger.output

<span class="comment"># Create a Test with a test number and a description.
</span>test1 = Test(1, &quot;<span class="string">Log method</span>&quot;)

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        log(&quot;<span class="string">Hello World</span>&quot;)
</pre>
</blockquote>

<p>Here we have created a single <code>Test</code> with the test
number <em>1</em> and the description <em>Log method</em>. Note how
must import the <code>Test</code> class in a similar manner to Java.
We've also take the opportunity to add a shorter alias for the
<code>grinder.logger.output</code> method.</p>

<p>So the console knows about the test, but we're still not using it
to record anything. Let's record how long our <code>log</code> method
takes. To instrument the <code>log</code> method we use our
<code>Test</code> to wrap it with a proxy <em>wrapper</em>. The
wrapper object looks exactly like the <code>log</code> method and can
be called in the same manner. If we call the wrapper the call will be
delegated through to the <code>log</code> method but additionally the
time taken to do the call and the number of calls will be recorded and
reported to the console.</p>

<blockquote>
<pre><span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test

log = grinder.logger.output

test1 = Test(1, &quot;<span class="string">Log method</span>&quot;)

<span class="comment"># Wrap the log() method with our Test and call the result logWrapper.
</span>logWrapper = test1.wrap(log)

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        logWrapper(&quot;<span class="string">Hello World</span>&quot;)
</pre>
</blockquote>

<p>This is a fully functional test script that works within The
Grinder framework and reports results to the console.</p>

<p>You're not restricted to wrapping method calls. In fact, its more
common to wrap objects. Here's an example using The Grinder's <a
href="./http-plugin.html">HTTP plug-in</a>.</p>

<blockquote>
<pre><span class="comment"># A simple example using the HTTP plugin that shows the retrieval of a
# single page via HTTP.
</span>
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test
<span class="keyword">from</span> net.grinder.plugin.http <span class="keyword">import</span> HTTPRequest

test1 = Test(1, &quot;<span class="string">Request resource</span>&quot;)
request1 = test1.wrap(HTTPRequest())

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        result = request1.GET(&quot;<span class="string">http://localhost:7001/</span>&quot;)
</pre>
</blockquote>

<h2>The Grinder script API</h2>

<p>With what you've seen already you have the full power of Jython at
your finger tips. You can use practically <em>any</em> Java or Python
code in your test scripts.</p>

<p>The Grinder script API can be used to access services from The
Grinder. The <a href="../script-javadoc/index.html">Javadoc</a>
contains full information on all the packages, classes and interfaces
that make up the core API, as well as additional packages added by the
shipped plug-ins. This section provides overview information on
various areas of the API. See also the <a
href="./http-plugin.html">HTTP plugin documentation</a>.</p>

<h3>The <code><a href="../script-javadoc/net/grinder/script/package-summary.html">net.grinder.script</a></code> package</h3>

<p>An instance of <code><a
href="../script-javadoc/net/grinder/script/ScriptContext.html">ScriptContext</a></code>
called <code>grinder</code> is available to all scripts. This object
provides access to context information and acts a starting point for
accessing other services.</p>

<p>We have described the use of the <code><a
href="../script-javadoc/net/grinder/script/Test.html">Test</a></code>
class <a href="#tests">above</a>.</p>

<p>The <code><a
href="../script-javadoc/net/grinder/script/Statistics.html">Statistics</a></code>
interface allows scripts to query whether tests where successful and
obtain statistic values such as transaction time of the last test. The
interface can also be used to modify or set a tests statistics before
they are sent to the log and the console.</p>


<h3>The <code><a href="../script-javadoc/net/grinder/common/package-summary.html">net.grinder.common</a></code> package</h3>

<p>This package contains common interfaces and utility classes that
are used throughout The Grinder and that are also useful to
scripts.</p>

<h3>The <code><a href="../script-javadoc/net/grinder/statistics/package-summary.html">net.grinder.statistics</a></code> package</h3>

<p>Scripts can use this package to report custom statistics and to
register additional views of standard and custom statistics.</p>

<p>Each statistic has a unique index object and a name. A statistic's
index is used when reporting values with the <code><a
href="../script-javadoc/net/grinder/script/Statistics.html">Statistics</a></code>
interface. Statistics can either be <em>long</em> integer values or
<em>double</em> floating-point values.</p>

<p>The standard long statistics used by The Grinder are:
<ul>
  <li><code>errors</code></li>
  <li><code>timedTransactions</code></li>
  <li><code>untimedTransactions</code></li>
  <li><code>timedTransactionTime</code></li>
  <li><code>period</code></li>
</ul></p>

<p>Additionally, there are five long statistics that scripts and
custom plug-ins can use for their own purposes, <code>userLong0</code>,
<code>userLong1</code>, ... <code>userLong4</code>.</p>

<p>The standard double statistics used by The Grinder are:
<ul>
  <li><code>peakTPS</code></li>
</ul></p>

<p>Additionally, there are five double statistics for use by scripts
and custom plug-ins, <code>userDouble0</code>,
<code>userDouble1</code>, ... <code>userDouble4</code>.</p>

<p>Views allow individual statistics to be combined in simple
expressions. For example <code>(/ errors (+ timedTransactions
untimedTransactions))</code> gives the ratio of errors to successful
transactions. New views can be registered using the
<code>grinder</code> object and automatically appear in the console
and the data file.</p>


<h2><a name="jython-installation">The Jython distribution and
installation</a></h2>

<p>The Grinder is shipped with a version of Jython but does not
package the Jython distribution of the standard Python library. If you
want to use the standard library, or if you want to use a different
version of Jython, obtain and install Jython and add the
installation's <code>jython.jar</code> to the start of the
<code>CLASSPATH</code> used to launch The Grinder.</p>

<p>Jython picks up user and site preferences from several sources (see
<a
href="http://www.jython.org/docs/registry.html">http://www.jython.org/docs/registry.html</a>).
A side effect of adding the installed <code>jython.jar</code> to the
start of the <code>CLASSPATH</code> is that <code>python.home</code>
can be correctly determined and the installed registry file will be
used.</p>

<p>A useful thing that you can set in the registry is
<code>python.cachedir</code>. This specifies a working directory which
Jython uses to store byte compiled python code. If you do not have
your own installed version of Jython in the <code>CLASSPATH</code>,
the working directory will be created in the directory which you run
The Grinder. This is fine for most casual users; if you are are
terribly worried about preserving disk space, read the information on
the Jython site.</p>


</body>
</html>
