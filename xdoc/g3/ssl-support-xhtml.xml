<?xml version="1.0" encoding="UTF-8"?>

<html>
<body>
<h1>SSL Support</h1>

<p>The Grinder 3 supports the use of SSL by scripts. When used with
the HTTP Plug-in, this is as simple as using <code>https</code>
instead of <code>http</code> in URIs. Scripts can obtain a suitable
<code>SSLContext</code> and hence a <code>SSLSocketFactory</code> for
non-HTTP use cases, and can control the allocation of SSL sessions to
worker threads.</p>

<p>The Grinder 3 supports SSL through the Java Secure Socket Extension
(JSSE). JSSE is a standard part of Java 2 Standard Edition 1.4.1 and
later. To simplify SSL and HTTPS configuration, JSSE is now
<em>required</em> for The Grinder 3. Consequently you may find it
easier to use J2SE 1.4.1 with The Grinder 3.</p>

<h2>Before we begin</h2>

<h3>Performance</h3>

<p>Simulating multiple SSL sessions on a single test machine may or
may not be realistic. A typical browser running on a desktop PC has
the benefit of a powerful CPU to run the SSL cryptography. Be careful
that your results aren't constrained due to inadequate test client CPU
power.</p>

<h3>The Grinder's SSL implementation is not secure</h3>

<p>To reduce the client side performance overhead, The Grinder
deliberately accelerates SSL initialisation by using a random number
generator that is seeded with a fixed number. Further, no validation
of server certificates is performed. Neither of these hinder SSL
communication, but they do make it less secure.</p>

<p><em><strong>Warning</strong> No guarantee is made as to the
cryptographic strength of any SSL communication using The
Grinder.</em></p>

<p>This acceleration affects initialisation time only and should not
affect timing information obtained using The Grinder.</p>

<h2>Controlling when new SSL sessions are created</h2>

<p>By default The Grinder creates a new SSL session for each run
carried out by each worker thread. This is in line with the usual
convention of simulating a user session with a worker thread executing
the part of the script defined by
<code>TestRunner.__call__()</code>.</p>

<p>Alternatively, scripts may wish to have an SSL session per worker
thread, i.e. for each thread to reuse SSL sessions on subsequent
executions of <code>TestRunner.__call__()</code>. This can be done
with the <code>SSLControl.setShareContextBetweenRuns()</code> method:</p>

<blockquote>
<pre>
<span class="keyword">from</span> net.grinder.script.Grinder <span class="keyword">import</span> grinder
grinder.SSLControl.shareContextBetweenRuns = 1
</pre>
</blockquote>

<p>This will cause each worker thread to reuse SSL sessions between
runs. SSL sessions will still not be shared between worker threads.
Calling <code>setShareContextBetweenRuns()</code> affects all of the
worker threads.</p>

<h2>Using client certificates</h2>

<p>If a server requests or requires a client certificate, The Grinder
must have some way of providing one - this usually involves specifying
key store. This can be done globally with the Java system
properties:</p>

<ul>
<li><code>javax.net.ssl.keyStore</code></li>
<li><code>javax.net.ssl.keyStoreType</code></li>
<li><code>javax.net.ssl.keyStorePassword</code></li>
</ul>

<p>The problem with specifying a key store using these properties is
that there can only be one an so all of the worker threads would use
the same client certificate. Most test scenarios require different
certificates to be used by each simulated user (worker thread).
Fortunately, The Grinder provides the <code>setKeyStoreFile</code>
method that can be used to specify the key store that a thread should
use.</p>

<blockquote>
<pre>
<span class="keyword">from</span> net.grinder.script.Grinder <span class="keyword">import</span> grinder

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(<span class="py-pseudo-keyword">self</span>):
        grinder.SSLControl.setKeyStoreFile("<span class="string">mykeystore.jks</span>", "<span class="string">passphrase</span>")
</pre>
</blockquote>

<p>It is only valid to use <code>setKeyStoreFile</code> from a worker
thread, and it only affects that worker thread.</p>

<p>There is also a method called <code>setKeyStore</code> which takes
a <code>java.io.InputStream</code> which may be useful if your key
store doesn't live on the local file system. Both methods have an
overloaded version that allows the key store type to be specified,
otherwise the default type is used (normally <code>jks</code>).</p>

<p>Whenever <code>setKeyStoreFile</code>, <code>setKeyStore</code>, or
<code>setKeyManagers</code> (see below) is called, the current SSL
session for the thread is discarded. Consequently, you usually want to
call these methods at the beginning of your <code>__call__()</code>
method or from the <code>TestRunner.__init__()</code> constructor.
Setting the thread's key store in <code>TestRunner.__init__()</code>
is especially recommended if you calling
<code>setShareContextBetweenRuns(true)</code> to share SSL sessions
between runs.</p>

<p>The astute reader who knows about key stores perhaps will have a
few questions. Here's a mini FAQ:</p>

<ol>
<li>
<p><em>If I have several suitable certificates in my key store, how
does The Grinder chose between them?</em></p>

<p>The Grinder relies on the JVM's default <code>KeyManager</code>
implementations. This picks a certificate from the store based on SSL
negotiation with the server. If there are several suitable
certificates, the only way to control which is used is to <a
href="#own-key-manager">provide your own
<code>KeyManager</code></a>.</p>
</li>

<li>
<p><em><code>setKeyStoreFile</code> has a parameter for the key store
password. What about the pass phrase that protects the private key in
the key store?</em></p>

<p>The pass phrases for keys must be the same as the key store
password. This is a restriction of the default
<code>KeyManager</code>s. If you don't like this, you can <a
href="#own-key-manager">provide your own
<code>KeyManager</code></a>.</p>
</li>

<li>
<p><em>Shouldn't I need to specify a set of certficiates for trusted
Certificate Authorities?</em></p>

<p>No. The Grinder does not validate certficates received from the
server, so does not need a set of CA certificates.</p>
</li>
</ol>

<h2><a name="own-key-manager">Picking a certificate from a key store
[Advanced]</a></h2>

<p>Here's an example script that provides its own
<code>X509KeyManager</code> implementation which controls which client
certificate to use. The example is hard coded to always use the
certificate with the alias <code>myalias</code>.</p>

<blockquote>
<pre>
<span class="keyword">from</span> com.sun.net.ssl <span class="keyword">import</span> KeyManagerFactory,X509KeyManager
<span class="keyword">from</span> java.io <span class="keyword">import</span> FileInputStream
<span class="keyword">from</span> java.security <span class="keyword">import</span> KeyStore
<span class="keyword">from</span> jarray <span class="keyword">import</span> array

<span class="keyword">class</span> <span class="type">MyManager</span>(X509KeyManager):
    <span class="keyword">def</span> <span class="function-name">__init__</span>(<span class="py-pseudo-keyword">self</span>, keyStoreFile, keyStorePassword):
        keyStore = KeyStore.getInstance("<span class="string">jks</span>")
        keyStore.load(FileInputStream(keyStoreFile), keyStorePassword)

        keyManagerFactory = \
         KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
        keyManagerFactory.init(keyStore, keyStorePassword)

        <span class="comment"># Assume we have one key manager.
</span>        <span class="py-pseudo-keyword">self</span>._delegate = keyManagerFactory.keyManagers[0]

    <span class="keyword">def</span> <span class="function-name">__getattr__</span>(<span class="py-pseudo-keyword">self</span>, a):
        """<span class="string">Some Python magic to pass on all invocations of methods we
        don't define on to our delegate."</span>""
        
        <span class="keyword">if</span> <span class="py-pseudo-keyword">self</span>.__dict__.has_key(a): <span class="keyword">return</span> <span class="py-pseudo-keyword">self</span>.__dict__[a]
        <span class="keyword">else:</span> <span class="keyword">return</span> <span class="py-builtins">getattr</span>(<span class="py-pseudo-keyword">self</span>._delegate, a)        

    <span class="keyword">def</span> <span class="function-name">chooseClientAlias</span>(<span class="py-pseudo-keyword">self</span>, keyTypes, issuers):
        <span class="keyword">return</span> "<span class="string">myalias</span>"

myManager = MyManager("<span class="string">keystore.jks</span>", "<span class="string">password</span>")
myManagerArray = array((myManager,), X509KeyManager)

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(<span class="py-pseudo-keyword">self</span>):
        grinder.SSLControl.setKeyManagers(myManagerArray)
        <span class="comment"># ...</span>
</pre>
</blockquote>

<h2>Debugging</h2>

<p>When debugging SSL interactions, you may find it useful to set the
following in <code>grinder.properties</code>.</p>

<blockquote>
<pre>
grinder.jvm.arguments=-Djavax.net.debug=ssl
<span class="comment"># or -Djavax.net.debug=all</span>
</pre>
</blockquote>

</body>
</html>
