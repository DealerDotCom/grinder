<?xml version="1.0" encoding="UTF-8"?>

<html>
<body>

<h1>The TCPProxy</h1>

<p><strong>The TCPProxy <a href="future.html#TCPProxyUpdate">does not
currently support</a> The Grinder 3 HTTP plug-in.</strong></p>

<p>The TCPProxy is a <em>proxy</em> that you can place in a TCP
stream. It filters the request and response streams, sending the
results to <code>stdout</code>. You can control its behaviour by
specifying different filters. Whilst the TCPProxy is very useful in
its own right, its main purpose as far as The Grinder goes is to
automatically generate scripts for the HTTP plugin.</p>

<h3>Starting the TCPProxy</h3>

<p>You invoke the TCPProxy with something like:</p>

<blockquote>
<pre>
CLASSPATH=/opt/grinder/lib/grinder.jar
export CLASSPATH

java net.grinder.TCPProxy
</pre>
</blockquote>

<p>Say <code>java net.grinder.TCPProxy -?</code> to get a list of
the command line options.</p>

<p>Suppose you want to capture a conversation with a server on host
<em>server</em>, port <em>7001</em>, you should say something
like:</p>

<blockquote>
<pre>
java net.grinder.TCPProxy -remoteHost server
</pre>
</blockquote>

<p>The TCPProxy will start and display the following information:</p>

<blockquote>
<pre>
Initialising standard proxy  engine with the parameters:
   Request filter:  net.grinder.tools.tcpproxy.EchoFilter
   Response filter: net.grinder.tools.tcpproxy.EchoFilter
   Local host:       localhost
   Local port:       8001
   Remote host:      localhost
   Remote port:      7001
Engine initialised, listening on port 8001
</pre>
</blockquote>

<p>You can then point your web browser at
<code>http://localhost:8001/</code> and exercise the application
through the browser. The TCPProxy will echo your requests to the
terminal and forward the requests to <code>localhost:7001</code>, as
well as echoing response from the server the terminal and returning
them to the browser.</p>

<h3><a name="http-proxy">Using the TCPProxy as an HTTP proxy</a></h3>

<p>One problem of running the TCPProxy as described above is that it
only forwards to a single remote host. Any links or redirects to other
hosts that the application returns to the browser will bypass the
TCPProxy, meaning that they will not feature in the test script.
This also applies to absolute URLs to the server.</p>

<p>When recording browser traffic, a much better way to use the
TCPProxy is to run it as an HTTP proxy:</p>

<blockquote>
<pre>
java net.grinder.TCPProxy -proxy
</pre>
</blockquote>

<p>This will make it listen as an HTTP proxy on port <code>8001</code>
(the default, you can change it with <code>-localPort</code>), and
forward requests onto the relevant remote host, while echoing out the
HTTP interactions.</p>

<p>You should set your browser connection settings to specify the
TCPProxy as the HTTP proxy (set <em>host</em> to be the host on which
the TCPProxy is running and <em>port></em> to be <code>8001</code>).
You then use your browser as normal, e.g. in the example in the
previous section you should use the direct address
<code>http://localhost:7001</code> in your browser.</p>

<p>The TCPProxy will run as a proxy for both HTTP and HTTPS if
you specify <code>-ssl</code>.</p>

<h3><a name="HTTPPluginTCPProxyFilter">Using the HTTPPluginTCPProxyFilter</a></h3>

<p>You can use the TCPProxy to generate an HTTP plugin script segment
suitable for use with The Grinder.</p>

<blockquote>
<pre>
java net.grinder.TCPProxy -proxy -httpPluginFilter
</pre>
</blockquote>

<p>The output of the HTTPPluginTCPProxyFilter looks like:</p>

<blockquote>
<pre>
Initialising standard proxy engine with the parameters:
   Request filter: net.grinder.plugin.http.HTTPPluginTCPProxyFilter
   Response filter: net.grinder.tools.tcpproxy.NullFilter
   Local host:       localhost
   Local port:       8001
   Listening as an HTTP proxy
   Engine initialised, listening on port 8001

  #
  # The Grinder version 2.8.3
  #
  # Script generated by the TCPProxy at 25-Apr-02 08:17:57
  #
  
  grinder.processes=1
  grinder.threads=1
  grinder.cycles=0 

  grinder.test0.sleepTime=11336
  grinder.test0.parameter.url=http://localhost:7001/
  grinder.test1.sleepTime=12168
  grinder.test1.parameter.url=http://localhost:7001/lah.html
  grinder.test2.sleepTime=411
  grinder.test2.parameter.url=http://localhost:7001/test.gif
  grinder.test3.sleepTime=4786
  grinder.test3.parameter.url=http://localhost:7001/lah.html
  grinder.test3.parameter.header.If-Modified-Since=Tue, 16 Jan 2001 16:26:42 GMT
  grinder.test4.sleepTime=311
  grinder.test4.parameter.url=http://localhost:7001/test.gif
  grinder.test4.parameter.header.If-Modified-Since=Mon, 06 Nov 2000 08:35:58 GMT
</pre>
</blockquote>

<p>The script part of this is sent to the <code>stdout</code> stream,
whereas the information messages are sent to <code>stderr</code>. You
can redirect the script part to a file if you wish:</p>

<blockquote>
<pre>
java net.grinder.TCPProxy -proxy -httpPluginFilter &gt; grinder.properties
</pre>
</blockquote>

<p>You can then use this file with The Grinder.</p>

<h3>SSL and HTTPS support</h3>

<p>The TCPProxy has SSL support. You must first install <a
href="http://java.sun.com/products/jsse/">the JSSE</a>.</p>

<p>SSL relationships are necessarily point to point. When you
interpose the TCPProxy you end up with:</p>

<blockquote>Client &lt;--- ssl1 ---&gt; TCPProxy &lt;--- ssl2
---&gt; Server</blockquote>

<p>Where <em>ssl1</em> and <em>ssl2</em> are two separate SSL
connections. Each SSL connection has its own set of client and server
certificates (both of which are optional).</p>

<p>The TCPProxy will negotiate appropriate certificates for both
connections using certificates specified in a key store. See the JSSE
documentation for how to set up a key store. There are three
parameters you can pass as command line options to the TCPProxy to
specify key store details:</p>

<blockquote>
<table>
<tr>
 <td><code>-keyStore <em>file</em></code></td>
 <td>The key store file.</td>
</tr>
<tr>
 <td><code>-keyStorePassword <em>password</em></code></td>
 <td>The password for the key store.</td>
</tr>
<tr>
 <td><code>-keyStoreType <em>type</em></code></td>
 <td>The type, defaults to <code>jks</code>.</td>
</tr>
</table>
</blockquote>

<p>You can also specify these with the corresponding
<code>javax.net.ssl.XXX</code> properties.</p>

<p>Here's an example of starting the TCPProxy as an HTTP/HTTPS proxy
using the <em>testkeys</em> key store provided with the JSSE
samples:</p>

<blockquote>
<pre>
java net.grinder.TCPProxy -ssl -proxy -keyStore testkeys -keyStorePassword passphrase
</pre>
</blockquote>

<p>Even if you are not using client certificates, you probably need to
specify a key store. This is because the proxy needs a server
certificate of its own:</p>

<blockquote>
Browser -----&gt; [ServerCert] Proxy ----&gt; [ServerCert2]
Target
</blockquote>

<p>You need to start the proxy with a key store containing a
self-signed server certificate. This is the certificate that the
browser will be presented with. If you fail to provide a server
certificate, you will get a <em>No available certificate corresponds
to the SSL cipher suites which are enabled</em> exception. The easiest
way to provide a certificate is to copy the <em>testkeys</em> file
from the JSSE samples distribution and start the proxy using:</p>

<blockquote>
<pre>
java net.grinder.TCPProxy -ssl -proxy -keyStore testkeys -keyStorePassword passphrase
</pre>
</blockquote>

<p>Alternatively you might want to generate your own. Here's an
example:</p>

<blockquote>
<pre>
  PASTON:philipa% keytool -genkey -keystore testkeys -storepass passphrase -keyalg rsa
  What is your first and last name?
    [Unknown]:  localhost
  What is the name of your organizational unit?
    [Unknown]:  Engineering
  What is the name of your organization?
    [Unknown]:  Grinders Inc
  What is the name of your City or Locality?
    [Unknown]:  Grindsville
  What is the name of your State or Province?
    [Unknown]:  Grindshire
  What is the two-letter country code for this unit?
    [Unknown]:  GR
  Is &lt;CN=localhost, OU=Engineering, O=Grinders Inc, L=Grindsville, ST=Grindshire, C=GR&gt; correct?
    [no]:  yes
  
  Enter key password for &lt;mykey&gt;
          (RETURN if same as keystore password):
  PASTON:philipa%
</pre>
</blockquote>

<p>The <em>first and last name</em> ought to match the server which
you run the proxy on, and you must specify <code>-keyalg rsa</code> to
generate a certificate that works with common browsers. See the
<code>keytool</code> notes in the JDK documentation for how to do more
tricks.</p>

<p>You may find <code>NullPointerException</code>s when using PKCS12
files generated by some tools, e.g. <code>openssl</code>. Use the Java
<code>keytool</code> utility to maintain key stores and you'll be
all right.</p>

<span class="sidebar">
<h3>The Sniff 'n' Grind web application</h3>

<p><em>Sniff 'n' Grind</em> is Paddy Spencer's J2EE web application
that automates the tasks involved using the TCPProxy to record and
replay HTTPPlugin scripts. This section contains rather minimal notes
on its use.</p>

<h4>Setup page</h4>

<p>In the setup page enter the starting URL; this is usually the front
page of the application you're testing. You need to include the
protocol in the URL, only HTTP and HTTPS are currently supported.
Click on the button to go to...</p>

<h4>Start TCPProxy page</h4>

<p>This page tells you what you need to change your browser proxy
settings to. You need to so this before clicking on the link to start
the page, otherwise your requests will go through the proxy you
normally use and the TCPProxy won't pick them up. Once you've set the
proxy, click on the <em>Click here to go to...</em> link, and the
start URL will be returned in a new window.</p>

<p>If you specify a certificate in the <code>web.xml</code> file, and
a secure starting URL (an HTTPS rather than HTTP one) then the web
application will let you sniff and grind your ssl-using web
application. The only difference you'll notice is that you will be
asked to accept an untrusted certificate from the server. This is
because the web application uses the certificate you give it as a
server certificate when you connect to it and as a client certificate
when it connects to your web application. So you'd better make sure
that it's one your app will accept!</p>

<p><em>Do not close the sniffer window.</em> If you do that you will
not be able to end the test and get your results.</p>

<p>In order not to be a resource hog, the sniffer proxy process will
timeout after a given number of seconds (configurable via the
<code>web.xml</code>), so if you don't do anything for a while, you
may find your proxy isn't there any more.</p>

<p>When you've finished the test, close the test window and rest your
browser proxy to it's original settings (you DID note down those
settings, didn't you?) and then click on the <em>stop</em> button. You
will be taken to...</p>

<h4>TCPProxy results page</h4>

<p>The Sniff 'n' Grind generates a number of files. As a minimum there
are two:

<ul>

<li><code>httpsniffer.err</code> - which contains the initial startup
information as well as any runtime errors that might have
occurred.</li>

<li><code>httpsniffer.out</code> - which contains the details of the
test(s).</li>

</ul>

If you wish to run the test manually, you need to copy these into your
<code>grinder.properties</code> file and run The Grinder in the normal
way. You will also need to cut and paste the various
<code>http-plugin-tcpproxy-post</code> files, if any.</p>

<p>If you instead want to run The Grinder right now, with your
recorded results, then click on the link and go to...</p>

<h4>The Grinder setup page</h4>

<p>Despite, or perhaps because of, the vast, bewildering array of
properties that can be set to control a Grinder session, the web
application (in its current incarnation) only allows you to set the
numbers of processes, threads and cycles from within the browser.
These default to one of each and have maximum settings (currently
hard-coded) of 5 processes, 25 threads and 50 cycles.</p>

<p>The <em>reset</em> button resets the values in the form (as you'd
expect) and <em>Grind me, baby!</em> does what it says, leading
to...</p>

<h4>Wait page</h4>

<p>The patience page. If I was a real <code>31337 h4x0r d00d</code>
I'd have written some kewl applet which would keep you entertained
with graphical and highly amusing pr0n animations to keep you
entertained while sneakily querying the server for whether The Grinder
has finished. However, I'm not and so you've got a rather dull page
with a five second refresh on it and a note saying, "Wait."</p>

<h4>The Grinder results page</h4>

<p>The results page simply presents the contents of the files in the
<code>log</code> directory (so if you've used some huge number of
threads and cycles, this page will be BIG) and gives you the options
to re-run the grinder against the same test, but with different
properties, or to record another test.</p>

</span>

</body>
</html>
