<?xml version="1.0" encoding="UTF-8"?>

<html>
<body>

<h1>The TCPProxy</h1>

<p>The TCPProxy is a <em>proxy</em> that you can place in a TCP
stream, such as the HTTP connection between your browser and a server.
It filters the request and response streams, sending the results to
the terminal window (<code>stdout</code>). You can control its
behaviour by specifying different filters.</p>

<blockquote>
<img src="../images/tcpproxy.gif" width="762" height="340"/>
</blockquote>

<p>The TCPProxy lets you see what's going on at a network level and is
very useful in its own right as a debugging tool. Its main purpose as
far as The Grinder goes is to automatically generate HTTP test scripts
that can be replayed with the HTTP plugin.</p>

<h3>Starting the TCPProxy</h3>

<p>You start the TCPProxy with something like:</p>

<blockquote>
<pre>
CLASSPATH=/opt/grinder/lib/grinder.jar
export CLASSPATH

java net.grinder.TCPProxy
</pre>
</blockquote>

<br/>

<p>Say <code>java net.grinder.TCPProxy -?</code> to get a list of
the command line options.</p>

<p>Suppose you want to capture a conversation with a server on host
<em>server</em>, port <em>7001</em>, you should say something
like:</p>

<blockquote>
<pre>
java net.grinder.TCPProxy -remoteHost server -remotePort 7001
</pre>
</blockquote>

<p>The TCPProxy will start and display the following information:</p>

<blockquote>
<pre>
Initialising standard proxy  engine with the parameters:
   Request filter:  net.grinder.tools.tcpproxy.EchoFilter
   Response filter: net.grinder.tools.tcpproxy.EchoFilter
   Local host:       localhost
   Local port:       8001
   Remote host:      localhost
   Remote port:      7001
Engine initialised, listening on port 8001
</pre>
</blockquote>

<p>You can then point your web browser at
<code>http://localhost:8001/</code> and exercise the application
through the browser. The TCPProxy will echo your requests to the
terminal and forward the requests to <code>localhost:7001</code>, as
well as echoing response from the server the terminal and returning
them to the browser. <code>8001</code> is the default port that the
TCPProxy listens on; you can specifiy an alternative port with
<code>-localPort</code>.</p>

<h3><a name="http-proxy">Using the TCPProxy as an HTTP proxy</a></h3>

<p>One problem of running the TCPProxy as described above is that it
only forwards to a single remote host. Another problem is that any
links or redirects to other hosts that the target application may
return to the browser will bypass the TCPProxy, meaning that these
requests will not feature in the test script. This also applies to any
absolute URLs returned by the server.</p>

<p>When recording browser traffic, a much better way to use the
TCPProxy is to run it as an HTTP proxy:</p>

<blockquote>
<pre>
java net.grinder.TCPProxy -proxy
</pre>
</blockquote>

<p>This will make the TCPProxy listen as an HTTP proxy on port
<code>8001</code> (the default, but you can change it with
<code>-localPort</code>), and forward requests onto the relevant
remote host, while echoing out the HTTP interactions. When
<code>-proxy</code> is specified, <code>-remoteHost</code> and
<code>-remotePort</code> are ignored. </p>

<p>You should set your browser connection settings to specify the
TCPProxy as the HTTP proxy (in the browser options dialog, set
<em>host</em> to be the host on which the TCPProxy is running and
<em>port</em> to be <code>8001</code>). You then use your browser as
normal, e.g. in the example in the previous section you should use the
direct address <code>http://localhost:7001</code> in your browser. The
TCPProxy appears to your browser just like any other HTTP proxy server
would.</p>

<p>The TCPProxy will run proxy both HTTP and HTTPS if you specify
<code>-ssl</code>. See <a href="#ssl">below</a> for details on setting
up SSL.</p>

<h3><a name="HTTPPluginTCPProxyFilter">Using the HTTPPluginTCPProxyFilter</a></h3>

<p>You can use the TCPProxy to generate an HTTP plugin script segment
suitable for use with The Grinder.</p>

<blockquote>
<pre>
java net.grinder.TCPProxy -proxy -httpPlugin
</pre>
</blockquote>

<p>The output of the HTTPPluginTCPProxyFilter looks like:</p>

<blockquote>
<pre>
Script will be generated to the files 'httpscript.py' and 'httpscript_tests.py'
Initialising standard proxy engine with the parameters:
   Request filter:  net.grinder.plugin.http.HTTPPluginTCPProxyFilter
   Response filter: net.grinder.plugin.http.HTTPPluginTCPProxyResponseFilter
   Local host:       localhost
   Local port:       8001
   Listening as an HTTP proxy
Engine initialised, listening on port 8001
</pre>
</blockquote>

<p>The generated script is written to two files,
<code>httpscript.py</code> and <code>httpscript_tests.py</code>. The
<code>httpscript.py</code> file contains the high level flow of
recorded tests. For example:</p>

<blockquote><pre>
<span class="comment"># httpscript.py
</span>
<span class="keyword">from</span> httpscript_tests <span class="keyword">import</span> *

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):

        tests[0].GET('<span class="string">http://localhost:7001/</span>')

        grinder.sleep(70)
        tests[1].GET('<span class="string">http://localhost:7001/index.jsp</span>')

        grinder.sleep(100)
        tests[2].GET('<span class="string">http://localhost:7001/images/header_index.gif</span>')

        grinder.sleep(190)
        tests[3].GET('<span class="string">http://localhost:7001/images/bullet.gif</span>')

        tests[4].GET('<span class="string">http://localhost:7001/images/built_on_bea.gif</span>')

        grinder.sleep(20)
        tests[5].GET('<span class="string">http://localhost:7001/images/transparent.gif</span>')

        grinder.sleep(2564)
        tests[6].GET('<span class="string">http://localhost:7001/examplesWebApp/index.jsp</span>')

        <span class="comment"># ..
</span>
</pre></blockquote>

<p>The details are kept in <code>httpscript_tests.py</code>  so that 
the <code>httpscript.py</code> file is more readable:</p>

<blockquote><pre>
<span class="comment"># httpscript_tests.py
</span>
<span class="keyword">from</span> HTTPClient <span class="keyword">import</span> NVPair
<span class="keyword">from</span> net.grinder.plugin.http <span class="keyword">import</span> HTTPRequest
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test

tests = {}

headers0 = ( NVPair('<span class="string">Accept</span>', '<span class="string">image/gif, image/x-xbitmap, image/jpeg,
    image/pjpeg, application/vnd.ms-powerpoint, application/vnd.ms-excel,
    application/msword, application/x-shockwave-flash, */*</span>'), 
            NVPair('<span class="string">Accept-Language</span>', '<span class="string">en-gb</span>'), )
request0 = HTTPRequest(headers = headers0)
tests[0] = Test(0, '<span class="string">GET </span>').wrap(request0)


request1 = HTTPRequest(headers = headers0)
tests[1] = Test(1, '<span class="string">GET index.jsp</span>').wrap(request1)

headers2 = ( NVPair('<span class="string">Accept</span>', '<span class="string">*/*</span>'), 
            NVPair('<span class="string">Accept-Language</span>', '<span class="string">en-gb</span>'), 
            NVPair('<span class="string">If-Modified-Since</span>', '<span class="string">Thu, 17 Jul 2003 08:33:25 GMT</span>'), 
            NVPair('<span class="string">Referer</span>', '<span class="string">http://localhost:7001/index.jsp</span>'), )
request2 = HTTPRequest(headers = headers2)
tests[2] = Test(2, '<span class="string">GET header_index.gif</span>').wrap(request2)

request3 = HTTPRequest(headers = headers2)
tests[3] = Test(3, '<span class="string">GET bullet.gif</span>').wrap(request3)

<span class="comment"># ...</span>
</pre></blockquote>

<p>Once you've recorded these files you just need to add a simple <a
href="./getting-started.html#properties"><code>grinder.properties</code></a>
file and you can replay the recorded scenario with The Grinder. Your
properties file should at least set <a
href="./getting-started.html#grinder.script">grinder.script</a> to
<code>"httpscript.py"</code>. The recorded scripts can be edited by
hand to suite your needs.</p>


<h3><a name="ssl">SSL and HTTPS support</a></h3>

<p>The TCPProxy has SSL support based on the <a
href="http://java.sun.com/products/jsse/">JSSE</a>. The JSSE is
required to use The Grinder, but is now part of Java 2 Standard
Edition 1.4.1, see the <a href="../download.html">Download page</a>
for further details.</p>

<p>SSL relationships are necessarily point to point. When you
interpose the TCPProxy in SSL communications between a browser and a
server, you end up with two SSL connections. Each SSL connection has
its own set of client and server certificates (both of which are
optional).</p>

<blockquote>
<img src="../images/tcpproxy-ssl.gif" width="762" height="200"/>
</blockquote>

<p>The TCPProxy will negotiate appropriate certificates for both
connections using certificates specified in a Java key store. See the
J2SE/JSSE documentation for how to set up a key store. There are three
parameters you can pass as command line options to the TCPProxy to
specify key store details:</p>

<blockquote>
<table>
<tr>
 <td><code>-keyStore <em>file</em></code></td>
 <td>The key store file.</td>
</tr>
<tr>
 <td><code>-keyStorePassword <em>password</em></code></td>
 <td>The password for the key store.</td>
</tr>
<tr>
 <td><code>-keyStoreType <em>type</em></code></td>
 <td>The type, defaults to <code>jks</code>.</td>
</tr>
</table>
</blockquote>

<p>You can also specify these with the corresponding
<code>javax.net.ssl.XXX</code> properties. Here's an example of
starting the TCPProxy as an HTTP/HTTPS proxy using the
<em>testkeys</em> key store provided with the JSSE samples:</p>

<blockquote>
<pre>
java net.grinder.TCPProxy -ssl -proxy -keyStore testkeys -keyStorePassword passphrase
</pre>
</blockquote>

<p>You will need to specify a key store even if you are not using
client certificates. This is because the proxy needs a server
certificate of its own. You need to start the proxy with a key store
containing a self-signed server certificate. This is the certificate
that the browser will be presented with. If you fail to provide a
server certificate, you will get a <em>No available certificate
corresponds to the SSL cipher suites which are enabled</em> exception.
The easiest way to provide a certificate is to copy the
<em>testkeys</em> file from the JSSE samples distribution and start
the proxy using:</p>

<blockquote>
<pre>
java net.grinder.TCPProxy -ssl -proxy -keyStore testkeys -keyStorePassword passphrase
</pre>
</blockquote>

<p>Alternatively you might want to generate your own. Here's an
example:</p>

<blockquote>
<pre>
  PASTON:philipa% keytool -genkey -keystore testkeys -storepass passphrase -keyalg rsa
  What is your first and last name?
    [Unknown]:  localhost
  What is the name of your organizational unit?
    [Unknown]:  Engineering
  What is the name of your organization?
    [Unknown]:  Grinders Inc
  What is the name of your City or Locality?
    [Unknown]:  Grindsville
  What is the name of your State or Province?
    [Unknown]:  Grindshire
  What is the two-letter country code for this unit?
    [Unknown]:  GR
  Is &lt;CN=localhost, OU=Engineering, O=Grinders Inc, L=Grindsville, ST=Grindshire, C=GR&gt; correct?
    [no]:  yes
  
  Enter key password for &lt;mykey&gt;
          (RETURN if same as keystore password):
  PASTON:philipa%
</pre>
</blockquote>

<p>The <em>first and last name</em> ought to match the server which
you run the proxy on, and you must specify <code>-keyalg rsa</code> to
generate a certificate that works with common browsers. See the
<code>keytool</code> notes in the J2SE documentation for how to do
more tricks.</p>

<p>You may find <code>NullPointerException</code>s when using PKCS12
files generated by some tools, e.g. <code>openssl</code>. Use the Java
<code>keytool</code> utility to maintain key stores and you'll be
all right.</p>

</body>
</html>
