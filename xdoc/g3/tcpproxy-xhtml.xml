<?xml version="1.0" encoding="UTF-8"?>

<html>
<body>

<h1>The TCPProxy</h1>

<p>The TCPProxy is a proxy process that you can place in a TCP stream,
such as the HTTP connection between your browser and a server. It
filters the request and response streams, sending the results to the
terminal window (<code>stdout</code>). You can control its behaviour
by specifying different filters.</p>

<blockquote>
<img src="../images/tcpproxy.gif" width="762" height="340"/>
</blockquote>

<p>The TCPProxy's main purpose is to automatically generate HTTP test
scripts that can be replayed with The Grinder's HTTP plugin. Because
the TCPProxy lets you see what's going on at a network level it is
also very useful as a debugging tool in its own right.</p>

<h3>Starting the TCPProxy</h3>

<p>You start the TCPProxy with something like:</p>

<blockquote>
<pre>
CLASSPATH=/opt/grinder/lib/grinder.jar
export CLASSPATH

java net.grinder.TCPProxy
</pre>
</blockquote>

<p>Say <code>java net.grinder.TCPProxy -?</code> to get a full list of
the command line options.</p>

<p>With no additional options, the TCPProxy will start and display the
following information:</p>

<blockquote>
<pre>
Initialising as an HTTP proxy with the parameters:
   Request filters:  EchoFilter
   Response filters: EchoFilter
   Local address:    localhost:8001
Engine initialised, listening on port 8001
</pre>
</blockquote>

<p>This indicates that the TCPProxy is listening as an HTTP proxy on
port <code>8001</code> (the default, but you can change it with
<code>-localPort</code>). You must now set your browser connection
settings to specify the TCPProxy as the HTTP proxy. In the browser
options dialog, set the proxy host to be the host on which the
TCPProxy is running and proxy port to be <code>8001</code>).</p>

<blockquote>
<img src="../images/proxy-preferences.png" width="562" height="462"/>
</blockquote>

<p>The TCPProxy appears to your browser just like any other HTTP proxy
server, and you can use your browser as normal. If you type
<code>http://grinder.sourceforge.net</code> into your browser it will
display The Grinder home page and the TCPProxy will output all of the
HTTP interactions between the browser and the SourceForge site.</p>

<p>The TCPProxy will proxy both HTTP and HTTPS if you specify
<code>-ssl</code>. See <a href="#ssl">below</a> for details on setting
up SSL.</p>

<h3><a name="HTTPPluginTCPProxyFilter">Using the HTTPPluginTCPProxyFilter</a></h3>

<p>You can use the TCPProxy to generate an HTTP plugin script suitable
for use with The Grinder.</p>

<blockquote>
<pre>
java net.grinder.TCPProxy -httpplugin
</pre>
</blockquote>

<p>The output of the HTTPPluginTCPProxyFilter looks like:</p>

<blockquote>
<pre>
Script will be generated to the files 'httpscript.py' and 'httpscript_tests.py'
Initialising as an HTTP proxy with the parameters:
   Request filters:  HTTPPluginTCPProxyFilter
   Response filters: HTTPPluginTCPProxyResponseFilter
   Local address:    localhost:8001
Engine initialised, listening on port 8001
</pre>
</blockquote>

<p>The generated script is written to two files,
<code>httpscript.py</code> and <code>httpscript_tests.py</code>. The
<code>httpscript.py</code> file contains the high level flow of
recorded tests. For example:</p>

<blockquote><pre>
<span class="comment"># httpscript.py
</span>
<span class="keyword">from</span> httpscript_tests <span class="keyword">import</span> *

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):

        tests[0].GET('<span class="string">http://localhost:7001/</span>')

        grinder.sleep(70)
        tests[1].GET('<span class="string">http://localhost:7001/index.jsp</span>')

        grinder.sleep(100)
        tests[2].GET('<span class="string">http://localhost:7001/images/header_index.gif</span>')

        grinder.sleep(190)
        tests[3].GET('<span class="string">http://localhost:7001/images/bullet.gif</span>')

        tests[4].GET('<span class="string">http://localhost:7001/images/built_on_bea.gif</span>')

        grinder.sleep(20)
        tests[5].GET('<span class="string">http://localhost:7001/images/transparent.gif</span>')

        grinder.sleep(2564)
        tests[6].GET('<span class="string">http://localhost:7001/examplesWebApp/index.jsp</span>')

        <span class="comment"># ..
</span>
</pre></blockquote>

<p>The details are kept in <code>httpscript_tests.py</code>  so that 
the <code>httpscript.py</code> file is more readable:</p>

<blockquote><pre>
<span class="comment"># httpscript_tests.py
</span>
<span class="keyword">from</span> HTTPClient <span class="keyword">import</span> NVPair
<span class="keyword">from</span> net.grinder.plugin.http <span class="keyword">import</span> HTTPRequest
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test

tests = {}

headers0 = ( NVPair('<span class="string">Accept</span>', '<span class="string">image/gif, image/x-xbitmap, image/jpeg,
    image/pjpeg, application/vnd.ms-powerpoint, application/vnd.ms-excel,
    application/msword, application/x-shockwave-flash, */*</span>'), 
            NVPair('<span class="string">Accept-Language</span>', '<span class="string">en-gb</span>'), )
request0 = HTTPRequest(headers = headers0)
tests[0] = Test(0, '<span class="string">GET </span>').wrap(request0)


request1 = HTTPRequest(headers = headers0)
tests[1] = Test(1, '<span class="string">GET index.jsp</span>').wrap(request1)

headers2 = ( NVPair('<span class="string">Accept</span>', '<span class="string">*/*</span>'), 
            NVPair('<span class="string">Accept-Language</span>', '<span class="string">en-gb</span>'), 
            NVPair('<span class="string">If-Modified-Since</span>', '<span class="string">Thu, 17 Jul 2003 08:33:25 GMT</span>'), 
            NVPair('<span class="string">Referer</span>', '<span class="string">http://localhost:7001/index.jsp</span>'), )
request2 = HTTPRequest(headers = headers2)
tests[2] = Test(2, '<span class="string">GET header_index.gif</span>').wrap(request2)

request3 = HTTPRequest(headers = headers2)
tests[3] = Test(3, '<span class="string">GET bullet.gif</span>').wrap(request3)

<span class="comment"># ...</span>
</pre></blockquote>

<p>Once you've recorded these files you just need to add a simple <a
href="./getting-started.html#properties"><code>grinder.properties</code></a>
file and you can replay the recorded scenario with The Grinder. Your
properties file should at least set <a
href="./getting-started.html#grinder.script">grinder.script</a> to
<code>"httpscript.py"</code>. The recorded scripts can be edited by
hand to suit your needs.</p>


<h3><a name="ssl">SSL and HTTPS support</a></h3>

<p>The TCPProxy has SSL support based on the <a
href="http://java.sun.com/products/jsse/">JSSE</a>. The JSSE is
required by The Grinder, and is now part of Java 2 Standard Edition
1.4.1, see the <a href="../download.html">Download page</a> for
further details.</p>

<p>SSL relationships are necessarily point to point. When you
interpose the TCPProxy in SSL communications between a browser and a
server you end up with two SSL connections. Each SSL connection has
its own set of client and server certificates (both of which are
optional).</p>

<blockquote>
<img src="../images/tcpproxy-ssl.gif" width="762" height="200"/>
</blockquote>

<p>The TCPProxy will negotiate appropriate certificates for both
connections using built-in certificates or in a user-specified Java
key store. In particular, the TCPProxy needs a self-signed server
certificate for the connection from the browser. By default, the
TCPProxy will use a built-in certificate.</p>

<p>Here's an example of starting the TCPProxy as an HTTP/HTTPS
proxy:</p>

<blockquote>
<pre>
java net.grinder.TCPProxy -ssl
</pre>
</blockquote>

<p>When first establishing a connection, your browser will present a
warning and confirmation dialog. This is because the built-in
certficate isn't authorised by any of the certificate authorities that
the browser trusts. Additionally the built-in certificate authorises
<code>localhost</code>, so if your server doesn't listen at this
address the browser will complain. Choose the "accept this certificate
for this session" option.</p>

<p><em><strong>Warning</strong>The Grinder deliberately accelerates
SSL initialisation by using a random number generator that is seeded
with a fixed number. This does not hinder SSL communication, but
theoretcially makes it less secure. No guarantee is made as to the
cryptographical strength of any SSL communication using The
Grinder.</em></p>

<p>Advanced users can specify their own server certificate for the
connection from the browser, or add client certificates for the
connection to the server, using the <code>-keystore</code>,
<code>-keystorepassword</code>, and <code>-keystoretype</code>
options. See the J2SE/JSSE documentation for how to set up a key
store. If you fail to provide a key store with a valid server
certificate, you may get a <em>No available certificate corresponds to
the SSL cipher suites which are enabled</em> exception, and your
browser may report that it cannot communicate as it has no common
encryption algorithms. Internet Explorer likes to be different. If
start the TCPProxy without a valid server certificate and then connect
through it using Internet Explorer, the TCPProxy will report "SSL peer
shut down incorrectly. The browser will just spin away until it times
out. The easiest way to provide a server certificate is to copy the
<em>testkeys</em> file from the <a
href="http://java.sun.com/j2se/1.4.1/docs/guide/security/jsse/samples/">JSSE
samples distribution</a> and start the proxy using:</p>

<blockquote>
<pre>
java net.grinder.TCPProxy -ssl -keyStore testkeys -keyStorePassword passphrase
</pre>
</blockquote>

<h3><a name="chained-proxies">Using the TCPProxy with other proxies</a></h3>

<p>The TCPProxy can be used with other HTTP/HTTPS proxies.</p>

<blockquote>
<img src="../images/tcpproxy-proxy.gif" width="762" height="172"/>
</blockquote>

<p>Use the <code>-httpproxy</code> option to specify the host name and
port of the proxy. Use the <code>-httpsproxy</code> option if your
HTTPS proxy requires separate settings.</p>

<h3><a name="port-forwarding-mode">Using the TCPProxy as a port
forwarder</a></h3>

<p>It is normally most useful to use the TCPProxy in its HTTP Proxy
mode as described above.</p>

<p>When using the TCPProxy as a debugging tool it occasionally is
useful to use it in <em>port forwarding</em> mode. This mode is
enabled when one or more of <code>-remotehost</code> and
<code>-remoteport</code> are specified. In port forwarding mode, the
TCPProxy simply listens on <code>localhost:localport</code> and forwards
to <code>remotehost:remoteport</code>.</p>

<p>To see why HTTP Proxy mode is usually better than port forwarding
mode when using a browser, consider what happens if the remote server
returns a page with an absolute URL link back to itself. If you click
on the link, the browser will contact the server directly, bypassing
the TCPProxy. Another disadvantage is that you can't use the TCPProxy
with more than one remote sever.</p>

<h3><a name="options-summary">Summary of TCPProxy options</a></h3>

<blockquote>
<table>

<tr>
 <td valign="top" width="30%"><code><a name="-colour">-colour</a></code></td>
 <td>Specify that a simple colour scheme should be used to distinguish
 request streams from response schemes. This uses terminal control
 codes that only work on ANSI compliant terminals.</td>
</tr>

<tr>
 <td valign="top"><code><a name="-console">-console</a></code></td>
 <td>Display a simple console that has a control button that allows
 The TCPProxy to be shutdown cleanly. This can help in certain
 situations where a hard kill of the TCPProxy process would loose
 output that is still buffered in memory .</td>
</tr>

<tr>
 <td valign="top"><code><a
 name="-httpplugin">-httpplugin</a></code></td>
 <td>Add a request filter and a response filter to produce a script
 for The Grinder suitable for use with the HTTP plugin.</td>
</tr>

<tr>
 <td valign="top"><code><a name="-httpproxy">-httpproxy</a>
 <em>host</em> <em>port</em></code></td>
 <td>Specify that output should be directed through <a
 href="#chained-proxies">another HTTP/HTTPS proxy</a>. This may help
 you reach the Internet. This option is not supported in <a
 href="#port-forwarding-mode">port forwarding mode</a>.</td>
</tr>

<tr>
 <td valign="top"><code><a name="-httpsproxy">-httpsproxy</a>
 <em>host</em> <em>port</em></code></td>
 <td>Specify that output should be directed through a HTTPS proxy.
 Overrides any <a href="#-httpproxy">setting</a>. This option is not
 supported in <a href="#port-forwarding-mode">port forwarding
 mode</a>.</td>
</tr>


<tr>
 <td valign="top"><code><a name="-keystore">-keystore</a>
 <em>file</em></code></td>
 <td>Specify a custom key store. Usually the built-in keystore is good
 enough so <code>-keystore</code> does not need to be specified. Only
 used if <a href="#-ssl">-ssl</a> is set.</td>
</tr>

<tr>
 <td valign="top"><code><a
 name="-keystorepassword">-keystorepassword</a>
 <em>password</em></code></td>
 <td>Set the key store password. Only used if <a
 href="-keystore">-keystore</a> and <a href="#-ssl">-ssl</a>
 are set. Optional for some key store types.</td>
</tr>

<tr>
 <td valign="top"><code><a name="-keystoretype">-keystoretype</a>
 <em>type</em></code></td>
 <td>Set the key store type. Only used if <a
 href="-keystore">-keystore</a> and <a href="#-ssl">-ssl</a> are set.
 If not specified, the default value depends on JSSE configuration but
 is usually <code>jks</code>.</td>
</tr>

<tr>
 <td valign="top"><code><a name="-localhost">-localhost</a>
 <em>host</em></code></td>
 <td>Set the host name or IP address to listen on. This must
 correspond to a local interface of the machine the TCPProxy is
 started on. The default is <code>localhost</code>.</td>
</tr>

<tr>
 <td valign="top"><code><a name="-localport">-localport</a>
 <em>port</em></code></td>
 <td>Set the port to listen on. The default is <code>8001</code>.</td>
</tr>

<tr>
 <td valign="top"><code><a name="-properties">-properties</a>
 <em>file</em></code></td>
 <td>Specify a file containing properties that are passed on to the
 filters.</td>
</tr>

<tr>
 <td valign="top"><code><a name="-remotehost">-remotehost</a>
 <em>host</em></code></td>
 <td>Set the host name or port the TCPProxy should connect to in <a
 href="#port-forwarding-mode">port forwarding mode</a>. The TCPProxy
 starts in port forwarding mode if either <code>-remotehost</code> or
 <a href="#-remoteport">-remoteport</a> is set. The default is
 <code>localhost</code>.</td>
</tr>

<tr>
 <td valign="top"><code><a name="-remoteport">-remoteport</a>
 <em>port</em></code></td>
 <td>Set the port the TCPProxy should connect to in <a
 href="#port-forwarding-mode">port forwarding mode</a>. The TCPProxy
 starts in port forwarding mode if either <a
 href="#-remotehost">-remotehost</a> or <code>-remoteport</code> is
 set. The default is <code>7001</code>.</td>
</tr>

<tr>
 <td valign="top"><code><a name="-requestfilter">-requestfilter</a>
 <em>filter</em></code></td>
 <td>Add a request filter. <code>filter</code> can be the name of a
 class that implements
 <code>net.grinder.tools.tcpproxy.TCPProxyFilter</code> or one of
 <code>NONE</code>, <code>ECHO</code>. The option can be specified
 multiple times, in which case the filters are invoked one after
 another. If the not specified, the default <code>ECHO</code> filter
 is used.</td>
</tr>

<tr>
 <td valign="top"><code><a name="-requestfilter">-responsefilter</a>
 <em>filter</em></code></td>
 <td>Add a response filter. <code>filter</code> can be the name of a
 class that implements
 <code>net.grinder.tools.tcpproxy.TCPProxyFilter</code> or one of
 <code>NONE</code>, <code>ECHO</code>. The option can be specified
 multiple times, in which case the filters are invoked one after
 another. If the not specified, the default <code>ECHO</code> filter
 is used.</td>
</tr>

<tr>
 <td valign="top"><code><a name="-ssl">-ssl</a></code></td>
 <td>Use SSL. In the normal <em>HTTP Proxy mode</em>, this will make
 the TCPProxy also listen as an HTTPS proxy. In <a
 href="#port-forwarding-mode">port forwarding mode</a> this will make
 both the TCPProxy's local socket and the connections to the target
 server use SSL.</td>
</tr>

<tr>
 <td valign="top"><code><a name="-timeout">-timeout</a>
 <em>seconds</em></code></td>
 <td>Set an idle timeout. This is how long the TCPProxy will wait for
 a request before timing out and freeing the local port. The TCPProxy
 will not time out if there are active connections.</td>
</tr>

</table>


</blockquote>

</body>
</html>
