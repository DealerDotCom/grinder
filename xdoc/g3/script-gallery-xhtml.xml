<?xml version="1.0" encoding="UTF-8"?>

<html>
<body>

<h1>Script Gallery</h1>

<p>This page contains examples of Jython scripts and script snippets
that can be used with The Grinder 3. The scripts can also be found in
the <code>examples</code> directory of the distribution. To use one of
these scripts, you'll need to set up a <a
href="./getting-started.html#properties"><code>grinder.properties</code></a>
file. Please also make sure you are using the latest beta version of
The Grinder 3.</p>

<p>If you're new to Python, it might help to know that that blocks are
delimited by lexical indentation.</p>

<p>The scripts make use of The Grinder <a
href="../script-javadoc/index.html">script API</a>. The
<code>grinder</code> object in the scripts is an instance of
<code>ScriptContext</code> through which the script can obtain
contextual information (such as the worker process ID) and services
(such as logging).</p>

<p>If you have a script that you would like to like to see to this
page, please send it to <a
href="mailto:grinder-use@lists.sf.net">grinder-use@lists.sf.net</a>.</p>

<toc/>

<hr/>

<h3><a name="hello-world">Hello World</a></h3>

<blockquote>
<pre><span class="comment"># A minimal script that tests The Grinder logging facility.
#
# This script shows the recommended style for scripts, with a
# TestRunner class. The script is executed just once by each worker
# process and defines the TestRunner class. The Grinder creates an
# instance of TestRunner for each worker thread, and repeatedly calls
# the instance for each run of that thread.
</span>
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test

<span class="comment"># A shorter alias for the grinder.logger.output() method.
</span>log = grinder.logger.output

<span class="comment"># Create a Test with a test number and a description. The test will be
# automatically registered with The Grinder console if you are using
# it.
</span>test1 = Test(1, &quot;<span class="string">Log method</span>&quot;)

<span class="comment"># Wrap the log() method with our Test and call the result logWrapper.
# Calls to logWrapper() will be recorded and forwarded on to the real
# log() method.
</span>logWrapper = test1.wrap(log)

<span class="comment"># A TestRunner instance is created for each thread. It can be used to
# store thread-specific data.
</span><span class="keyword">class</span> <span class="type">TestRunner</span>:
    
    <span class="comment"># This method is called for every run.
</span>    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        logWrapper(&quot;<span class="string">Hello World</span>&quot;)
</pre>
</blockquote>

<hr/>

<h3><a name="http">Simple HTTP example</a></h3>

<blockquote>
<pre><span class="comment"># A simple example using the HTTP plugin that shows the retrieval of a
# single page via HTTP. The resulting page is written to a file.
#
# More complex HTTP scripts are best created with the TCPProxy.
</span>
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test
<span class="keyword">from</span> net.grinder.plugin.http <span class="keyword">import</span> HTTPRequest

test1 = Test(1, &quot;<span class="string">Request resource</span>&quot;)
request1 = test1.wrap(HTTPRequest())

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        result = request1.GET(&quot;<span class="string">http://localhost:7001/</span>&quot;)

        <span class="comment"># result is a HTTPClient.HTTPResult. We get the message body
</span>        <span class="comment"># using the getText() method.
</span>        writeToFile(result.text)

<span class="comment"># Utility method that writes the given string to a uniquely named file
# using a FilenameFactory.
</span><span class="keyword">def</span> <span class="function-name">writeToFile</span>(text):
    filename = grinder.getFilenameFactory().createFilename(
        &quot;<span class="string">page</span>&quot;, &quot;<span class="string">-%d.html</span>&quot; % grinder.runNumber)

    file = open(filename, &quot;<span class="string">w</span>&quot;)
    <span class="keyword">print</span> &gt;&gt; file, text
    file.close()
</pre>
</blockquote>

<hr/>

<h3><a name="scenario">Recording many HTTP interactions as one test</a></h3>

<blockquote>
<pre><span class="comment"># This example shows how many HTTP interactions can be grouped as a
# single test by wrapping them in a function.
</span>
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test
<span class="keyword">from</span> net.grinder.plugin.http <span class="keyword">import</span> HTTPRequest
<span class="keyword">from</span> HTTPClient <span class="keyword">import</span> NVPair

log = grinder.logger.output

<span class="comment"># We declare a default URL for the HTTPRequest.
</span>request = HTTPRequest(url = &quot;<span class="string">http://localhost:7001</span>&quot;)

<span class="keyword">def</span> <span class="function-name">page1</span>():
    request.GET('<span class="string">/console</span>')
    request.GET('<span class="string">/console/login/LoginForm.jsp</span>')
    request.GET('<span class="string">/console/login/bea_logo.gif</span>')

page1Test = Test(1, &quot;<span class="string">First page</span>&quot;).wrap(page1)

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        page1Test()
</pre>
</blockquote>

<hr/>

<h3><a name="fba">HTTP/J2EE form based authentication</a></h3>

<blockquote>
<pre><span class="comment"># A more complex HTTP example based on an authentication conversation
# with the server. This script demonstrates how to follow different
# paths based on a response returned by the server and how to post
# HTTP form data to a server.
#
# The J2EE Servlet specification defines a common model for form based
# authentication. When unauthenticated users try to access a protected
# resource, they are challenged with a logon page. The logon page
# contains a form that POSTs username and password fields to a special
# j_security_check page.
</span>
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test
<span class="keyword">from</span> net.grinder.plugin.http <span class="keyword">import</span> HTTPRequest
<span class="keyword">from</span> HTTPClient <span class="keyword">import</span> NVPair

log = grinder.logger.output

protectedResourceTest = Test(1, &quot;<span class="string">Request resource</span>&quot;)
authenticationTest = Test(2, &quot;<span class="string">POST to j_security_check</span>&quot;)

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        request = protectedResourceTest.wrap(
            HTTPRequest(url=&quot;<span class="string">http://localhost:7001/console</span>&quot;))

        result = request.GET()
       
        result = maybeAuthenticate(result)

        result = request.GET()

<span class="comment"># Function that checks the passed HTTPResult to see whether
# authentication is necessary. If it is, perform the authentication
# and record performance information against Test 2.
</span><span class="keyword">def</span> <span class="function-name">maybeAuthenticate</span>(lastResult):
    <span class="keyword">if</span> lastResult.statusCode == 401 \
    <span class="keyword">or</span> lastResult.text.find(&quot;<span class="string">j_security_check</span>&quot;) != -1:
        
        log(&quot;<span class="string">Challenged, authenticating</span>&quot;)

        authenticationFormData = ( NVPair(&quot;<span class="string">j_username</span>&quot;, &quot;<span class="string">weblogic</span>&quot;),
                                   NVPair(&quot;<span class="string">j_password</span>&quot;, &quot;<span class="string">weblogic</span>&quot;),)

        request = authenticationTest.wrap(
            HTTPRequest(url=&quot;<span class="string">%s/j_security_check</span>&quot; % lastResult.originalURI))
            
        <span class="keyword">return</span> request.POST(authenticationFormData)
</pre>
</blockquote>

<hr/>

<h3><a name="cookies">HTTP cookies</a></h3>

<blockquote>
<pre><span class="comment"># HTTP example which shows how to access HTTP cookies.
#
# By default, the HTTPClient library handles Cookie interaction and
# removes the cookie headers from responses. If you want to access
# them, one way is to define your own CookiePolicyHandler. This script
# defines a CookiePolicyHandler that simply logs all cookies that are
# sent or received.
</span>
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test
<span class="keyword">from</span> net.grinder.plugin.http <span class="keyword">import</span> HTTPRequest, HTTPPluginControl
<span class="keyword">from</span> HTTPClient <span class="keyword">import</span> CookieModule, CookiePolicyHandler

log = grinder.logger.output

<span class="keyword">class</span> <span class="type">MyCookiePolicyHandler</span>(CookiePolicyHandler):
    <span class="keyword">def</span> <span class="function-name">acceptCookie</span>(self, cookie, request, response):
        log(&quot;<span class="string">accept cookie: %s</span>&quot; % cookie)
        <span class="keyword">return</span> 1
        
    <span class="keyword">def</span> <span class="function-name">sendCookie</span>(self, cookie, request):
        log(&quot;<span class="string">send cookie: %s</span>&quot; % cookie)
        <span class="keyword">return</span> 1

CookieModule.setCookiePolicyHandler(MyCookiePolicyHandler())

test1 = Test(1, &quot;<span class="string">Request resource</span>&quot;)
request1 = test1.wrap(HTTPRequest())   

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        result = request1.GET(&quot;<span class="string">http://localhost:7001/console</span>&quot;)
</pre>
</blockquote>

<hr/>

<h3><a name="form">HTTP multipart form submission</a></h3>

<blockquote>
<pre><span class="comment"># This script uses the HTTPClient.Codecs class to post itself to the
# server as a multi-part form. Thanks to Marc Gemis.
</span>
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test
<span class="keyword">from</span> net.grinder.plugin.http <span class="keyword">import</span> HTTPRequest
<span class="keyword">from</span> HTTPClient <span class="keyword">import</span> Codecs, NVPair
<span class="keyword">from</span> jarray <span class="keyword">import</span> zeros

log = grinder.logger.output

test1 = Test(1, &quot;<span class="string">Upload Image</span>&quot;)
request1 = test1.wrap(HTTPRequest(url=&quot;<span class="string">http://localhost:7001/</span>&quot;))

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):

        files = ( NVPair(&quot;<span class="string">self</span>&quot;, &quot;<span class="string">form.py</span>&quot;), )
        parameters = ( NVPair(&quot;<span class="string">run number</span>&quot;, str(grinder.runNumber)), )

        <span class="comment"># This is the Jython way of creating an NVPair[] Java array
</span>        <span class="comment"># with one element.
</span>        headers = zeros(1, NVPair)

        <span class="comment"># Create a multi-part form encoded byte array.
</span>        data = Codecs.mpFormDataEncode(parameters, files, headers)
        log(&quot;<span class="string">Content type set to %s</span>&quot; % headers[0].value)

        <span class="comment"># Call the version of POST that takes a byte array.
</span>        result = request1.POST(&quot;<span class="string">/upload</span>&quot;, data, headers);
</pre>
</blockquote>

<hr/>

<h3><a name="ejb">Enterprise Java Beans</a></h3>

<blockquote>
<pre><span class="comment"># Exercise a stateful session EJB from the BEA WebLogic Server 7.0
# examples. Additionally this script demonstrates the use of the
# ScriptContext sleep(), getThreadId() and getRunNumber() methods.
#
# Before running this example you will need to add the EJB client
# classes to your CLASSPATH.
</span>
<span class="keyword">from</span> java.lang <span class="keyword">import</span> String
<span class="keyword">from</span> java.util <span class="keyword">import</span> Properties,Random
<span class="keyword">from</span> javax.naming <span class="keyword">import</span> Context,InitialContext
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test
<span class="keyword">from</span> weblogic.jndi <span class="keyword">import</span> WLInitialContextFactory

log = grinder.logger.output

tests = {
    &quot;<span class="string">home</span>&quot; : Test(1, &quot;<span class="string">TraderHome</span>&quot;),
    &quot;<span class="string">trade</span>&quot; : Test(2, &quot;<span class="string">Trader buy/sell</span>&quot;),
    &quot;<span class="string">query</span>&quot; : Test(3, &quot;<span class="string">Trader getBalance</span>&quot;),   
    }

<span class="comment"># Initial context lookup for EJB home.
</span>p = Properties()
p[Context.INITIAL_CONTEXT_FACTORY] = WLInitialContextFactory.name

home = InitialContext(p).lookup(&quot;<span class="string">ejb20-statefulSession-TraderHome</span>&quot;)
homeTest = tests[&quot;<span class="string">home</span>&quot;].wrap(home)

random = Random()

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        trader = homeTest.create()

        tradeTest = tests[&quot;<span class="string">trade</span>&quot;].wrap(trader)

        stocksToSell = { &quot;<span class="string">BEAS</span>&quot; : 100, &quot;<span class="string">MSFT</span>&quot; : 999 }
        <span class="keyword">for</span> stock, amount <span class="keyword">in</span> stocksToSell.items():
            tradeResult = tradeTest.sell(&quot;<span class="string">John</span>&quot;, stock, amount)
            log(&quot;<span class="string">Result of tradeTest.sell(): %s</span>&quot; % tradeResult)

        grinder.sleep(100)              <span class="comment"># Idle a while
</span>
        stocksToBuy = { &quot;<span class="string">BEAS</span>&quot; : abs(random.nextInt()) % 1000 }
        <span class="keyword">for</span> stock, amount <span class="keyword">in</span> stocksToBuy.items():
            tradeResult = tradeTest.buy(&quot;<span class="string">Phil</span>&quot;, stock, amount)
            log(&quot;<span class="string">Result of tradeTest.buy(): %s</span>&quot; % tradeResult)            

        queryTest = tests[&quot;<span class="string">query</span>&quot;].wrap(trader)
        balance = queryTest.getBalance();
        log(&quot;<span class="string">Balance is $%.2f</span>&quot; % balance)

        trader.remove()                 <span class="comment"># We don't record the remove() as a test
</span>
        <span class="comment"># Can obtain information about the thread context...
</span>        <span class="keyword">if</span> grinder.threadID == 0 <span class="keyword">and</span> grinder.runNumber == 0:
            <span class="comment"># ...and navigate from the proxy back to the test
</span>            d = queryTest.__test__
            log(&quot;<span class="string">Query test is test %d, (%s)</span>&quot; % (d.number, d.description))
</pre>
</blockquote>

<hr/>

<h3><a name="jdbc">Grinding a database with JDBC</a></h3>

<blockquote>
<pre><span class="comment"># Some simple database playing with JDBC.
#
# To run this, set the Oracle login details appropriately and add the
# Oracle thin driver classes to your CLASSPATH.
</span>
<span class="keyword">from</span> java.sql <span class="keyword">import</span> DriverManager
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test
<span class="keyword">from</span> oracle.jdbc <span class="keyword">import</span> OracleDriver

log = grinder.logger.output

test1 = Test(1, &quot;<span class="string">Database insert</span>&quot;)
test2 = Test(2, &quot;<span class="string">Database query</span>&quot;)

<span class="comment"># Load the Oracle JDBC driver.
</span>DriverManager.registerDriver(OracleDriver());

<span class="keyword">def</span> <span class="function-name">getConnection</span>():
    <span class="keyword">return</span> DriverManager.getConnection(
        &quot;<span class="string">jdbc:oracle:thin:@127.0.0.1:1521:mysid</span>&quot;, &quot;<span class="string">wls</span>&quot;, &quot;<span class="string">wls</span>&quot;)

<span class="keyword">def</span> <span class="function-name">ensureClosed</span>(object):
    <span class="keyword">try:</span> object.close()
    <span class="keyword">except:</span> <span class="keyword">pass</span>

<span class="comment"># One time initialisation that cleans out old data.
</span>connection = getConnection()
statement = connection.createStatement()

<span class="keyword">try:</span> statement.execute(&quot;<span class="string">drop table grinder_fun</span>&quot;)
<span class="keyword">except:</span> <span class="keyword">pass</span>

statement.execute(&quot;<span class="string">create table grinder_fun(thread number, run number)</span>&quot;)

ensureClosed(statement)
ensureClosed(connection)
    
<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        connection = None
        statement = None

        <span class="keyword">try:</span>
	    connection = getConnection()
	    statement = connection.createStatement()
            
            testInsert = test1.wrap(statement)
            testInsert.execute(&quot;<span class="string">insert into grinder_fun values(%d, %d)</span>&quot; %
                               (grinder.threadID, grinder.runNumber))

            testQuery = test2.wrap(statement)
            testQuery.execute(&quot;<span class="string">select * from grinder_fun where thread=%d</span>&quot; %
                              grinder.threadID)

	<span class="keyword">finally:</span>
            ensureClosed(statement)
	    ensureClosed(connection)
</pre>
</blockquote>

<hr/>

<h3><a name="amazon">Simple HTTP Web Service</a></h3>

<blockquote>
<pre><span class="comment"># Calls an Amazon.com web service to obtain information about a book.
#
# To run this script you must install the standard Python xml module.
# Here's one way to do that:
#
#   1. Download and install Jython 2.1
#   2. Add the following line to grinder.properties (changing the path appropriately):
#           grinder.jvm.arguments=-Dpython.home=c:/jython-2.1
#   3. Add Jakarta Xerces (or one of the other parsers supported by
#       the xml module) to your CLASSPATH.
#
# You may also need to obtain your own Amazon.com web service license
# and replace the script text &lt;insert license key here&gt; with the
# license key, although currently that doesn't appear to be necessary.
</span><span class="string">
from net.grinder.script import Test
</span><span class="keyword">from</span> net.grinder.plugin.http <span class="keyword">import</span> HTTPRequest
<span class="keyword">from</span> HTTPClient <span class="keyword">import</span> NVPair
<span class="keyword">from</span> xml.dom <span class="keyword">import</span> javadom
<span class="keyword">from</span> org.xml.sax <span class="keyword">import</span> InputSource

bookDetailsTest = Test(1, &quot;<span class="string">Get book details from Amazon</span>&quot;)
parser = javadom.XercesDomImplementation()
        
<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        <span class="keyword">if</span> grinder.runNumber &gt; 0 <span class="keyword">or</span> grinder.threadID &gt; 0:
            <span class="keyword">raise</span> RuntimeError(&quot;<span class="string">Use limited to one thread, one run; </span>&quot;
                               &quot;<span class="string">see Amazon Web Services terms and conditions</span>&quot;)
        
        request = bookDetailsTest.wrap(
            HTTPRequest(url=&quot;<span class="string">http://xml.amazon.com/onca/xml</span>&quot;))

        parameters = (
            NVPair(&quot;<span class="string">v</span>&quot;, &quot;<span class="string">1.0</span>&quot;),
            NVPair(&quot;<span class="string">f</span>&quot;, &quot;<span class="string">xml</span>&quot;),
            NVPair(&quot;<span class="string">t</span>&quot;, &quot;<span class="string">webservices-20</span>&quot;),
            NVPair(&quot;<span class="string">dev-t</span>&quot;, &quot;<span class="string">&lt;insert license key here&gt;</span>&quot;),
            NVPair(&quot;<span class="string">type</span>&quot;, &quot;<span class="string">heavy</span>&quot;),
            NVPair(&quot;<span class="string">AsinSearch</span>&quot;, &quot;<span class="string">1904284000</span>&quot;),
            )
        
        bytes = request.POST(parameters).inputStream

        <span class="comment"># Parse results
</span>        document = parser.buildDocumentUrl(InputSource(bytes))

        result = {}
        
        <span class="keyword">for</span> details <span class="keyword">in</span> document.getElementsByTagName(&quot;<span class="string">Details</span>&quot;):
            <span class="keyword">for</span> detailName <span class="keyword">in</span> (&quot;<span class="string">ProductName</span>&quot;, &quot;<span class="string">SalesRank</span>&quot;, &quot;<span class="string">ListPrice</span>&quot;):
                result[detailName] = details.getElementsByTagName(
                    detailName)[0].firstChild.nodeValue

        grinder.logger.output(str(result))
</pre>
</blockquote>

<hr/>

<h3><a name="jaxrpc">JAX-RPC Web Service</a></h3>

<blockquote>
<pre><span class="comment"># Exercise a basic Web Service from the BEA WebLogic Server 7.0
# examples.
#
# Before running this example you will need to add the generated
# JAX-RPC client classes and webserviceclient.jar to your CLASSPATH.
</span>
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test
<span class="keyword">from</span> examples.webservices.basic.javaclass <span class="keyword">import</span> HelloWorld_Impl
<span class="keyword">from</span> java.lang <span class="keyword">import</span> System

System.setProperty( &quot;<span class="string">javax.xml.rpc.ServiceFactory</span>&quot;,
 &quot;<span class="string">weblogic.webservice.core.rpc.ServiceFactoryImpl</span>&quot;);

webService = HelloWorld_Impl(&quot;<span class="string">http://localhost:7001/basic_javaclass/HelloWorld?WSDL</span>&quot;);

port  = webService.getHelloWorldPort();
portTest = Test(1, &quot;<span class="string">JAXP Port test</span>&quot;).wrap(port)

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        result = portTest.sayHello(grinder.threadID, grinder.grinderID);
        grinder.logger.output(&quot;<span class="string">Got '%s'</span>&quot; % result);
</pre>
</blockquote>

<hr/>

<h3><a name="hello-world-functions">Hello World, with functions</a></h3>

<blockquote>
<pre><span class="comment"># The Hello World example re-written using functions.
#
# In previous examples we've defined TestRunner as a class; calling
# the class creates an instance and calling that instance invokes its
# __call__ method. This script is for the Luddites amongst you and
# shows how The Grinder engine is quite happy as long as the script
# creates a callable thing called TestRunner that can be called to
# create another callable thing.
</span>
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test

log = grinder.logger.output

test1 = Test(1, &quot;<span class="string">Log method</span>&quot;)
logTest = test1.wrap(log)

<span class="keyword">def</span> <span class="function-name">doRun</span>():
    logTest(&quot;<span class="string">Hello World</span>&quot;)

<span class="keyword">def</span> <span class="function-name">TestRunner</span>():
    <span class="keyword">return</span> doRun
</pre>
</blockquote>

<hr/>

<h3><a name="statistics">Accessing test statistics</a></h3>

<blockquote>
    <pre><span class="comment"># Examples of using The Grinder statistics API with standard
# statistics.
</span>
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test
<span class="keyword">from</span> net.grinder.plugin.http <span class="keyword">import</span> HTTPRequest

log = grinder.logger.output
logError = grinder.logger.error

test1 = Test(1, &quot;<span class="string">Request resource</span>&quot;)
request1 = test1.wrap(HTTPRequest())

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        statistics = grinder.statistics

        <span class="comment"># Example 1. You can get the time of the last test as follows.
</span>        result = request1.GET(&quot;<span class="string">http://localhost:7001/</span>&quot;)
        log(&quot;<span class="string">The last test took %d milliseconds</span>&quot; % statistics.time)

        
        <span class="comment"># Example 2. Normally test results are reported automatically
</span>        <span class="comment"># when the test returns. If you want to alter the statistics
</span>        <span class="comment"># after a test has completed, you must set delayReports = 1 to
</span>        <span class="comment"># delay the reporting before performing the test. This only
</span>        <span class="comment"># affects the current worker thread.
</span>        statistics.delayReports = 1

        result = request1.GET(&quot;<span class="string">http://localhost:7001/</span>&quot;)

        <span class="keyword">if</span> statistics.time &gt; 5:
            <span class="comment"># We set success = 0 to mark the test as a failure. This
</span>            <span class="comment"># discards the transaction time to comply with the
</span>            <span class="comment"># convention of only recording time for successful tests,
</span>            <span class="comment"># so lets log the actual time to the error log.
</span>            logError(&quot;<span class="string">The last test took too long (%d milliseconds)</span>&quot; %
                     statistics.time)
            statistics.success = 0

        <span class="comment"># With delayReports = 1 you can call report() to explicitly.
</span>        statistics.report()

        <span class="comment"># You can also turn the automatic reporting back on.
</span>        statistics.delayReports = 0
</pre>
</blockquote>

<hr/>

<h3><a name="jms-sender">Java Message Service - Queue Sender</a></h3>

<blockquote>
<pre><span class="comment"># An example JMS sender.
#
# JMS objects are looked up and messages are created once during
# initialisation. This default JNDI names are for the WebLogic Server
# 7.0 examples domain - change accordingly.
#
# Each worker thread:
#  - Creates a queue session
#  - Sends ten messages
#  - Closes the queue session
</span>
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test
<span class="keyword">from</span> jarray <span class="keyword">import</span> zeros
<span class="keyword">from</span> java.util <span class="keyword">import</span> Properties, Random
<span class="keyword">from</span> javax.jms <span class="keyword">import</span> Session
<span class="keyword">from</span> javax.naming <span class="keyword">import</span> Context, InitialContext
<span class="keyword">from</span> weblogic.jndi <span class="keyword">import</span> WLInitialContextFactory

<span class="comment"># Look up connection factory and queue in JNDI. 
</span>properties = Properties()
properties[Context.PROVIDER_URL] = &quot;<span class="string">t3://localhost:7001</span>&quot;
properties[Context.INITIAL_CONTEXT_FACTORY] = WLInitialContextFactory.name

initialContext = InitialContext(properties)

connectionFactory = initialContext.lookup(&quot;<span class="string">weblogic.examples.jms.QueueConnectionFactory</span>&quot;)
queue = initialContext.lookup(&quot;<span class="string">weblogic.examples.jms.exampleQueue</span>&quot;)
initialContext.close()

<span class="comment"># Create a connection.
</span>connection = connectionFactory.createQueueConnection()
connection.start()

<span class="comment"># Create a couple of BytesMessages.
</span>session = connection.createQueueSession(0, Session.AUTO_ACKNOWLEDGE)

random = Random()

<span class="keyword">def</span> <span class="function-name">createBytesMessage</span>(size):
    bytes = zeros(size, '<span class="string">b</span>')
    random.nextBytes(bytes)
    message = session.createBytesMessage()
    message.writeBytes(bytes)
    <span class="keyword">return</span> message

message = createBytesMessage(100)

session.close()

<span class="keyword">class</span> <span class="type">TestRunner</span>:
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        log = grinder.logger.output

        log(&quot;<span class="string">Creating queue session</span>&quot;)
        session = connection.createQueueSession(0, Session.AUTO_ACKNOWLEDGE)

        sender = session.createSender(queue)
        instrumentedSender = Test(1, &quot;<span class="string">Send a message</span>&quot;).wrap(sender)

        log(&quot;<span class="string">Sending ten messages</span>&quot;)

        <span class="keyword">for</span> i <span class="keyword">in</span> range(0, 10):
            instrumentedSender.send(message)
            grinder.sleep(100)

        log(&quot;<span class="string">Closing queue session</span>&quot;)
        session.close()
</pre>
</blockquote>

<hr/>

<h3><a name="jms-receiver">Java Message Service - Queue Receiver</a></h3>

<blockquote>
<pre><span class="comment"># An example JMS receiver.
#
# JMS objects are looked up and messages are created once during
# initialisation. This default JNDI names are for the WebLogic Server
# 7.0 examples domain - change accordingly.
#
# Each worker thread:
#  - Creates a queue session
#  - Receives ten messages
#  - Closes the queue session
#
# This script demonstrates the use of The Grinder statistics API to
# record a &quot;delivery time&quot; custom statistic.
</span>
<span class="keyword">from</span> java.lang <span class="keyword">import</span> System
<span class="keyword">from</span> java.util <span class="keyword">import</span> Properties
<span class="keyword">from</span> javax.jms <span class="keyword">import</span> MessageListener, Session
<span class="keyword">from</span> javax.naming <span class="keyword">import</span> Context, InitialContext
<span class="keyword">from</span> net.grinder.script <span class="keyword">import</span> Test
<span class="keyword">from</span> net.grinder.statistics <span class="keyword">import</span> ExpressionView, StatisticsIndexMap, StatisticsView
<span class="keyword">from</span> threading <span class="keyword">import</span> Condition
<span class="keyword">from</span> weblogic.jndi <span class="keyword">import</span> WLInitialContextFactory

<span class="comment"># Look up connection factory and queue in JNDI. 
</span>properties = Properties()
properties[Context.PROVIDER_URL] = &quot;<span class="string">t3://localhost:7001</span>&quot;
properties[Context.INITIAL_CONTEXT_FACTORY] = WLInitialContextFactory.name

initialContext = InitialContext(properties)

connectionFactory = initialContext.lookup(&quot;<span class="string">weblogic.examples.jms.QueueConnectionFactory</span>&quot;)
queue = initialContext.lookup(&quot;<span class="string">weblogic.examples.jms.exampleQueue</span>&quot;)
initialContext.close()

<span class="comment"># Create a connection.
</span>connection = connectionFactory.createQueueConnection()
connection.start()

<span class="comment"># Use userLong0 statistic to represent the &quot;delivery time&quot;.
</span>deliveryTimeIndex = StatisticsIndexMap.getInstance().getIndexForLong(&quot;<span class="string">userLong0</span>&quot;)

<span class="comment"># Add two statistics views:
# 1. Delivery time:- the mean time taken between the server sending
# the message and the receiver receiving the message.
# 2. Mean delivery time:- the delivery time averaged over all
# transactions.
</span>
detailView = StatisticsView()
detailView.add(ExpressionView(&quot;<span class="string">Delivery time</span>&quot;, &quot;&quot;, &quot;<span class="string">userLong0</span>&quot;))
	    
summaryView = StatisticsView()
summaryView.add(ExpressionView(
    &quot;<span class="string">Mean delivery time</span>&quot;,
    &quot;<span class="string">statistic.deliveryTime</span>&quot;,
    &quot;<span class="string">(/ userLong0(+ timedTransactions untimedTransactions))</span>&quot;))
	    
grinder.registerDetailStatisticsView(detailView)
grinder.registerSummaryStatisticsView(summaryView)

<span class="comment"># We record each message receipt against a single test. The
# transaction time is meaningless.
</span><span class="keyword">def</span> <span class="function-name">recordDeliveryTime</span>(deliveryTime):
    grinder.statistics.setValue(deliveryTimeIndex, deliveryTime)

recordTest = Test(1, &quot;<span class="string">Receive messages</span>&quot;).wrap(recordDeliveryTime)

<span class="keyword">class</span> <span class="type">TestRunner</span>(MessageListener):

    <span class="keyword">def</span> <span class="function-name">__init__</span>(self):
        self.receivedMessages = 0    
        self.cv = Condition()           <span class="comment"># Used to synchronise thread activity.
</span>
    <span class="keyword">def</span> <span class="function-name">__call__</span>(self):
        log = grinder.logger.output

        log(&quot;<span class="string">Creating queue session and a receiver</span>&quot;)
        session = connection.createQueueSession(0, Session.AUTO_ACKNOWLEDGE)

        receiver = session.createReceiver(queue)
        receiver.messageListener = self

        <span class="comment"># Read 10 messages from the queue.
</span>        <span class="keyword">for</span> i <span class="keyword">in</span> range(0, 10):

            <span class="comment"># Wait until we have received a message.            
</span>            self.cv.acquire()
            <span class="keyword">while</span> self.receivedMessages == 0: self.cv.wait()
            self.receivedMessages -= 1
            self.cv.release()

            log(&quot;<span class="string">Received message</span>&quot;)

            <span class="comment"># We record the test a here rather than in onMessage
</span>            <span class="comment"># because we must do so from a worker thread.
</span>            recordTest(self.lastDeliveryTime)

        log(&quot;<span class="string">Closing queue session</span>&quot;)
        session.close()

        <span class="comment"># Rather than over complicate things with explict message
</span>        <span class="comment"># acknowledgement, we simply discard any additional messages
</span>        <span class="comment"># we may have read.
</span>        log(&quot;<span class="string">Received %d additional messages</span>&quot; % self.receivedMessages)

    <span class="comment"># Called asynchronously by JMS when a message arrives.
</span>    <span class="keyword">def</span> <span class="function-name">onMessage</span>(self, message):
        self.cv.acquire()

        self.receivedMessages += 1

        <span class="comment"># In WebLogic Server JMS, the JMS timestamp is set by the
</span>        <span class="comment"># sender session. All we need to do is ensure our clocks are
</span>        <span class="comment"># synchronised...
</span>        self.lastDeliveryTime = System.currentTimeMillis() - message.getJMSTimestamp()
        self.cv.notifyAll()
        self.cv.release()
</pre>
</blockquote>

</body>
</html>
