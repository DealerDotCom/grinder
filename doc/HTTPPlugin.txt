This file contains notes about the use of The Grinder HTTP Plugin.


What can I set in grinder.properties for the HTTP plugin?
*********************************************************

    grinder.plugin.parameter.useCookies -
				Set to false to disable cookie
				handling (it defaults to true).

    grinder.plugin.parameter.useCookiesVersionString -
				Set to false to remove $Version string
				from cookies (it defaults to true).
				This is to work around broken (?)
				JRun 2.3.3. behavour.

    grinder.plugin.parameter.followRedirects -
				Set to true to automatically follow
				redirects, so you don't have to have
				additional URL's in you scripts. The
				default is false.

				You should always set this to false for
				TCPSnffer generated scripts.

				If you are using WebLogic Server and
				Web Application form-based
				authentication you leave this property
				set to false. This is because a
				redirect request that follows
				authentication contains a key cookie -
				setting the property to true prevents
				the cookie from being picked up by the
				plugin.

    grinder.plugin.parameter.timeIncludesTransaction -

				By default the time that the HTTP
				plugin reports is the time it takes
				for the remote server to accept the
				connection request. When using the
				times as an indicator of user
				experience, this is usually what you
				want.

				Sometimes however you are more
				interested in the time the entire HTTP
				transaction takes, including the time
				required to read the entire HTTP
				response over the network. If so, set
				this parameter to true.

    grinder.plugin.parameter.stringBean -
				Fully qualified classname of a Java
				bean that can provide dynamic strings
				for URL's and POST data. See "What's a
				String Bean?" below.

    grinder.test0.parameter.url -
				The URL to call. The HTTP GET method
				is used unless
			 	grinder.test0.parameter.post is
			 	specified.

    grinder.test0.parameter.ok	-
				Fail if the returned page doesn't
			 	contain this string.

    grinder.test0.parameter.post -
				Specify a file containing POST data to
			 	send.

    grinder.test0.parameter.ifModifiedSince -
				This appears in the HTTP
			 	"If-Modified-Since" request header,
			 	allowing the grinder to simulate the
			 	a browser's caching of pages. Its value
				should be a date of the form
				Sat, 06 Jan 2001 13:36:39 GMT.

    grinder.test0.parameter.basicAuthenticationUser -
    grinder.test0.parameter.basicAuthenticationPassword -
				Used togther, these specify an HTTP
				basic authentication header that will
				be sent with the request. The values
				can be varied using a String Bean, see
				"What's a String Bean?" below.

What's a String Bean?
*********************

When using the HTTP plugin, it is often necessary to parametrise parts
of URL's, POST data, and other request strings. The easy way to do
this is to use a "String Bean" - a Java Bean that returns Strings from
its "get" methods.

For example, supporse you wanted to modify the URL
"http://myhost/test.jsp?n=1" such that n is set to a random number
each time? Easy! Here's how.

Write a simple bean:

  // MyStringBean.java
  package mystuff;

  public class MyStringBean {
    private Random m_random = new Random();

    public String getRandomInteger() {
      return Integer.toString(m_random.nextInt());
    }
  }

Compile this and put it in your classpath. Then alter your
grinder.properties to include this line:

  grinder.plugin.parameter.stringBean=mystuff.MyStringBean

Alter the test URL parameter as follows:

  grinder.test0.parameter.url=http://myhost/test.jsp?n=<getRandomInteger>


The <beanMethodName> syntax can be used in any URL string or POST data
file. It must correspond to a public method of the string bean that
takes no parameters and returns a String.

Each string bean instance is instantiated per thread, and maintains
its state between invocations. If your bean needs additional
information regarding the test lifecycle (for example, to reset a
counter and the beginning of a cycle), it can implement the
net.grinder.http.plugin.StringBean interface. See the examples in
net.grinder.http.plugin.example.


How do I use the HTTPS plugin?
******************************

1) Install JSSE1.0.2. See
   http://java.sun.com/products/jsse/INSTALL.html

2) In your grinder.properties, use the HttpsPlugin rather than
   HttpPlugin:

	grinder.plugin=net.grinder.plugin.http.HttpsPlugin

3) You can then use https:// in your URLs

	grinder.plugin.parameter.url0=https://localhost:7002/snoop
	grinder.plugin.parameter.ok0=Requested URL:

4) If you want two-way authentication, add the following lines

	grinder.plugin.parameter.clientCert=./philclient.p12
	grinder.plugin.parameter.clientCertPassword=acrobat

	(export p12 from netscape)

The JSSE SSL implementation isn't quick. This should be taken into
account when comparing round trip times, as a compiled browser version
is likely to be a *lot* faster.


HTTPClient
**********

The HTTP plugin now has *experimental* support for Ronald Tschalär's
excellent HTTPClient library instead of HttpURLConnection.

Unfortunately experimentation shows HTTPClient sometimes does not
perform well in a multithreaded environment. I'm guessing this should
be straightforward to fix.

To use specify that the HTTP plugin should use HTTPClient instead of
HttpURLConnection, say

    grinder.plugin.parameter.useHTTPClient=true


HTTPClient versus HttpURLConnection
***********************************

HTTPClient has many more features than HttpURLConnection, see
http://www.innovation.ch/java/HTTPClient/urlcon_vs_httpclient.html for
a comparision.

I hope to lever features such as proxy support, connection timeouts
and persistent cookies into future versions of The Grinder.

One of the key advantages for The Grinder is that HTTPClient allows
explicit control of connection management, whereas HttpURLConnection
uses connection pooling "under the covers".

In my experience, HTTPClient is _much_ more RFC compliant, and less
buggy than HttpURLConnection.

I do know of one thing which IMHO is an non-compliance however. I have
fixed this in The Grinder version. Here's my description from my bug
report to Ronald Tschalär:

  I've encountered a problem with how HTTPClient 0.3.3 encodes query
  strings, e.g:

    public HTTPResponse Get(String file, String query, NVPair[] headers)
		throws IOException, ModuleException
    {
	String File = stripRef(file);
	if (query != null  &&  query.length() > 0)
	    File += "?" + Codecs.URLEncode(query);

	    //...


  where Codecs.URLEncode() calls  java.net.URLEncoder.encode().


  AFAICT, this is not correct. According to RFC 2396, 3.4:

    Within a query component, the characters ";", "/", "?", ":", "@",
    "&", "=", "+", ",", and "$" are reserved.

  and RFC 2396, 2.2:

    2.2. Reserved Characters

    Many URI include components consisting of or delimited by, certain
    special characters. These characters are called "reserved", since
    their usage within the URI component is limited to their reserved
    purpose. If the data for a URI component would conflict with the
    reserved purpose, then the conflicting data must be escaped before
    forming the URI.

      reserved    = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
                    "$" | ","

    The "reserved" syntax class above refers to those characters that
    are allowed within a URI, but which may not be allowed within a
    particular component of the generic URI syntax; they are used as
    delimiters of the components described in Section 3.

    Characters in the "reserved" set are not reserved in all contexts.
    The set of characters actually reserved within any given URI
    component is defined by that component. In general, a character is
    reserved if the semantics of the URI changes if the character is
    replaced with its escaped US-ASCII encoding.


  AFAICS, you should only escape the parts of the query string that
  are not the "?", "&" or "=" delimiters. Further, as there is no way
  to distinguish whether these characters are actually delimiters or
  just data, HTTPClient can't do this. You'd have to provide an API
  that allowed the user to build up a query string, escaping the data
  appropriately.

  In the meantime, I strongly suggest removing the URLEncode calls
  from HTTPConnection. I know of at least one popular application
  server (no prizes :-)) which would correctly interpret the
  HTTPClient encoding of "a=b", namely "a%3Db" as a key of "a=b" and a
  value of null.

