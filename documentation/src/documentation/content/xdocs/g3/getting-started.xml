<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">

<document>
<header>
  <title>Getting started</title>
</header>

<body>
  <note>This section takes a top down approach to The Grinder. If you
  are happy figuring things out for yourself and want to get your
  hands dirty, you might like to read <a href="#howtostart">How do I
  start The Grinder?</a> and then jump to the <a
  href="site:script-gallery">Script Gallery</a>.</note>

  <section>
    <title>The Grinder processes</title>

    <p>The Grinder is a framework for running test scripts across a
    number of machines. The framework is comprised of three types of
    <em>process</em> (or program). <em>Worker processes</em>,
    <em>agent processes</em> and the <em> <a
    href="site:console">console</a></em>. The responsibilities of
    each of the process types are:</p>

    <ul>
      <li>
        <strong>Worker processes</strong>
        <ul>
          <li>Interpret Jython test scripts and performs tests using a
          number of <em>worker threads</em></li>
        </ul>
      </li>

      <li>
        <strong>Agent processes</strong>
        <ul>
          <li>Manage worker processes</li>
          <li>A single agent process runs on each client machine</li>
        </ul>
      </li>

      <li>
        <strong>The console</strong>
        <ul>
          <li>Coordinates the other processes</li>
          <li>Collates and displays statistics</li>
        </ul>
      </li>
    </ul>

    <p>As The Grinder is written in Java, each of these processes is a
    Java Virtual Machine (JVM).</p>

    <p>For heavy duty testing, you start an agent process on each of
    several client machines. The worker processes they launch can be
    controlled and monitored using the console. There is little reason
    to run more than one agent on a single machine, but if you can if
    you wish.</p>
  </section>

  <section>
    <title>Tests and test scripts</title>

    <p>A <em>test</em> is a unit of work against which statistics are
    recorded. Users specify which tests to run using a Jython <a
    href="site:scripts-intro">test script</a>. Tests are uniquely defined by
    a <em>test number</em> and may also have a <em>description</em>.
    If you wish your scripts can report many different actions (e.g.
    different web page requests) against the same test, The Grinder
    will aggregate the results.</p>

    <p>The script is executed many times in a typical testing
    scenario. Each worker process has a number of worker threads, and
    each worker thread calls the script a number of times. A single
    execution of a test script is called a <em>run</em>.</p>
  </section>

  <section id="howtostart">
    <title>How do I start The Grinder?</title>

    <p>Its easy:</p>

    <ol>
      <li>Create a <a
      href="#properties"><code>grinder.properties</code></a> file.
      This file specifies general control information (how the worker
      processes should contact the console, how many worker processes
      to use, ..), as well as the name of the Jython script that will
      be used to run the tests.<p/></li>

      <li>Set your <code>CLASSPATH</code> to include the
      <code>grinder.jar</code> file which can be found in the
      <code>lib</code> directory.<p/></li>

      <li>Start the console on one of the test machines:
<source>
java net.grinder.Console
</source></li>

      <li>For each test machine, do steps 1. and 2. and start an agent
      process:
<source>
java net.grinder.Grinder
</source>
        <p>You can also specify an explicit properties file as the
        first argument. For example:</p>

<source>
java net.grinder.Grinder myproperties
</source>
      </li>
    </ol>

    <p>The console does not read the <code>grinder.properties</code>
    file. It has its own options dialog (choose the
    <em>File/Options</em> menu option) which you should use to set the
    communication addresses and ports to match those in the
    <code>grinder.properties</code> files. The <a
    href="site:console/process-controls">console controls</a> can be
    used to trigger The Grinder test scenario. Each agent process then
    creates child worker processes to do the work.</p>

    <p>As the worker processes execute, they dynamically inform the
    console of the tests in the test script. If you start the console
    after the agent process, you should press the <em>Reset
    processes</em> button. This will cause the existing worker
    processes to exit and the agent process to start fresh worker
    processes which will update the console with the new test
    information.</p>

    <p>Included below are some sample shell scripts, for both unix/linux and windows,
    for starting grinder agents, its console, and the HTTPProxy.</p>
    
    <p><strong>Windows:</strong></p>
    <ul>
     <li>setGrinderEnv.cmd:
<source>
set GRINDERPATH=<em>(full path to grinder install directory)</em>
set CLASSPATH=%CLASSPATH%;%GRINDERPATH%\lib\grinder.jar
set CLASSPATH=%CLASSPATH%;%GRINDERPATH%\lib\jython.jar
set JAVA_HOME=<em>(full path to java install directory)</em>
set JAVA_BINDIR=%JAVA_HOME%\bin
PATH=%JAVA_BINDIR%;%PATH%
</source>    
     </li>
     <li>startAgent.cmd:
<source>
call <em>(path to setGrinderEnv.cmd)</em>\setGrinderEnv.cmd
echo %CLASSPATH%
java -cp %CLASSPATH% net.grinder.Grinder <em>(path to grinder.properties)</em>\grinder.properties
</source>
     </li>
     <li>startConsole.cmd:
<source>
call <em>(path to setGrinderEnv.cmd)</em>\setGrinderEnv.cmd
java -cp %CLASSPATH% net.grinder.Console
</source>
     </li>
     <li>startProxy.cmd:
<source>
Call <em>(path to setGrinderEnv.cmd)</em>\setGrinderEnv.cmd
java -cp %CLASSPATH% net.grinder.TCPProxy -console -httpPlugin
</source>
     </li>
    </ul>

    <p><strong>Unix:</strong></p>
     <ul>
      <li>setGrinderEnv.sh:
<source>
#!/usr/bin/ksh
GRINDERPATH=<em>(full path to grinder install directory)</em>
CLASSPATH=$CLASSPATH:$GRINDERPATH/lib/grinder.jar
CLASSPATH=$CLASSPATH:$GRINDERPATH/lib/jython.jar
JAVA_HOME=<em>(full path to java install directory)</em>
JAVA_BINDIR=$JAVA_HOME/bin
PATH=$JAVA_BINDIR:$PATH
export CLASSPATH PATH
</source>
      </li>
      <li>startAgent.sh:
<source>
#!/usr/bin/ksh
. <em>(path to setGrinderEnv.sh)</em>/setGrinderEnv.sh
java -cp $CLASSPATH net.grinder.Grinder <em>(path to grinder.properties)</em>/grinder.properties
</source>
      </li>
      <li>startConsole.sh:
<source>
#!/usr/bin/ksh
. <em>(path to setGrinderEnv.sh)</em>/setGrinderEnv.sh
java -cp $CLASSPATH net.grinder.Console
</source>
      </li>
      <li>startProxy.sh:
<source>
#!/usr/bin/ksh
. <em>(path to setGrinderEnv.sh)</em>/setGrinderEnv.sh
java -cp $CLASSPATH net.grinder.TCPProxy -console -httpPlugin 
</source>
      </li>
     </ul>
  </section>

  <section>
    <title>Network communication</title>

    <p>Each worker process sets up a TCP network connection to the
    console to report statistics. Each agent process sets up a
    connection to the console to receive commands, which it passes on
    to its worker processes. The console accepts both types of
    connection on a particular address and port. By default, the
    console listens on port <code>6372</code> on all local network
    interfaces of the machine running the console.</p>

    <p>To change the console addresses, set the
    <code>grinder.consoleHost</code> and
    <code>grinder.consolePort</code> properties in the <a
    href="#properties"><code>grinder.properties</code></a> file before
    starting The Grinder agents. The values must match those specified
    in the console options dialog.</p>

    <p>If an agent process fails to connect to the console, or the
    <code>grinder.useConsole</code> property is <code>false</code>,
    the agent will continue independently without the console and
    automatically will start its worker processes. The worker
    processes will run to completion and not report to the
    console.</p>
  </section>

  <section>
    <title>Output</title>

    <p>Each worker process writes logging information to a file called
    <code>out-host-n.log</code>, where <code> host</code> is the
    machine host name and <code>n</code> is the worker process number.
    Errors are written to <code>error-host-n.log</code>. If no errors
    occur, an error file will not be created. Data about individual
    test invocations is written into a file called
    <code>data-host-n.log</code> that can be imported into a
    spreadsheet tool such as Microsoft Excel<sup>TM</sup> for further
    analysis.</p>

    <p>The final statistics summary (in the <code>out-*</code> files
    of each process) looks something like this:</p>

<source>
Final statistics for this process:

              Successful
              Tests         Errors        Average (ms)  
Test 0        25            0             255.52        
Test 1        25            0             213.40        
Test 2        25            0             156.80         "Image"
Test 3        25            0             90.48         
Test 4        25            0             228.68         "Login page"
Test 5        25            0             86.12          "Security check"
Test 6        25            0             216.20        
Test 7        25            0             73.20         
Test 8        25            0             141.92        
Test 9        25            0             104.68         "Logout page"

Totals        250           0             156.70     
</source>

    <p>The console has a dynamic display of similar information
    collected from all the worker processes.</p>

    <p>Each test has one of two possible outcomes:</p>

    <ol>
      <li>Success. The number of <em>Successful Tests</em> for that
      test is incremented The time taken to perform the test is added
      to the <em>Total</em>.</li>

      <li>Error. The execution of a test raised an exception. The
      number of <em>Errors</em> for the test is incremented.</li>
    </ol>

    <p>The <em>Total</em> and <em>Average</em> figures are calculated
    based only on successful tests.</p>
  </section>

  <section id="properties">
    <title>The properties file</title>

    <p>The Grinder worker and agent processes are controlled by
    setting properties in the <code>grinder.properties</code>
    file.</p>

    <p>All properties have default values. If you start The Grinder
    agent process without a <code>grinder.properties</code> file it
    will communicate with the console using default addresses, use one
    worker process, one thread, and make one run through the test
    script found in the file <code>grinder.py</code>. This is not much
    use, so read on...</p>

    <section>
      <title>Table of properties</title>

      <p>This table lists the properties understood by The Grinder
      engine.</p>

      <table>
        <tr>
          <th>Property</th>
          <th>Description</th>
          <th>Default</th>
        </tr>

        <tr>
          <td>
            <code>grinder.processes</code>
          </td>

          <td>The number of worker processes the agent should start.</td>

          <td>1</td>
        </tr>

        <tr>
          <td>
            <code>grinder.threads</code>
          </td>

          <td>The number of worker threads that each worker process
          spawns.</td>

          <td>1</td>
        </tr>

        <tr>
          <td>
            <code>grinder.runs</code>
          </td>

          <td>The number of runs of the test script each thread
          performs. 0 means "run forever", and should be used when you
          are using the console to control your test runs.</td>

          <td>1</td>
        </tr>

        <tr>
          <td>
            <code>grinder.processIncrement</code>
          </td>

          <td>If set, the agent will <em>ramp up</em> the number of
          worker processes, starting the number specified every
          <code>grinder.processesIncrementInterval</code> milliseconds.
          </td>

          <td>Start all worker processes together.</td>
	</tr>

        <tr>
          <td>
            <code>grinder.processIncrementInterval</code>
          </td>

          <td>Used in conjunction with
          <code>grinder.processIncrement</code>, this property sets
          the interval in milliseconds at which the agent starts new
          worker processes.</td>

          <td>60000 ms</td>
	</tr>

        <tr>
          <td>
            <code>grinder.initialProcesses</code>
          </td>

          <td>Used in conjunction with
          <code>grinder.processIncrement</code>, this property sets
          the initial number of worker processes to start.</td>

          <td>The value of <code>grinder.processIncrement</code>.</td>
        </tr>

        <tr>
          <td>
            <code>grinder.duration</code>
          </td>

          <td>The maximum length of time in milliseconds that each
          worker process should run for. <code>grinder.duration</code>
          can be specified in conjunction with
          <code>grinder.runs</code>, in which case the worker
          processes will terminate if either the duration time or the
          number of runs is exceeded.</td>

          <td>Run forever.</td>
        </tr>

        <tr>
          <td>
            <code>grinder.script</code>
          </td>

          <td>The file name of the Jython <a
          href="site:scripts-intro">script</a> to run.</td>

          <td>grinder.py</td>
        </tr>

        <tr>
          <td>
            <code>grinder.jvm</code>
          </td>

          <td>Use an alternate JVM for worker processes. Defaults to
          <code>java</code> so you do not need to specify this if your
          <code>PATH</code> is sensible.</td>

          <td>java</td>
	</tr>

        <tr>
          <td>
            <code>grinder.jvm.classpath</code>
          </td>

          <td>Use to adjust the classpath used for the worker process
          JVMs. Anything specified here will be prepended to the
          classpath used to start the Grinder processes.</td>

          <td></td>
	</tr>

        <tr>
          <td>
            <code>grinder.jvm.arguments</code>
          </td>

          <td>Additional arguments to worker process JVMs.</td>

          <td></td>
	</tr>

        <tr>
          <td>
            <code>grinder.logDirectory</code>
          </td>

          <td>Directory to write log files to. Created if it doesn't
          already exist.</td>

          <td>The local directory.</td>
	</tr>

        <tr>
          <td>
            <code>grinder.numberOfOldLogs</code>
          </td>

          <td>The number of archived logs from previous runs that
          should be kept.</td>

          <td>1</td>
	</tr>

        <tr>
          <td>
            <code>grinder.hostID</code>
          </td>

          <td>Override the "host" string used in log filenames and logs.</td>

          <td>The host name.</td>
	</tr>

        <tr>
          <td>
            <code>grinder.consoleHost</code>
          </td>

          <td>The IP address or hostname to use for communication
          between the agent and worker processes and the console.</td>

          <td>All the network interfaces of the local machine.</td>
	</tr>

        <tr>
          <td>
            <code>grinder.consolePort</code>
          </td>

          <td>The IP port to use for communication that the agent and
          worker processes use to contact to the console.</td>

          <td>>6372</td>
	</tr>

        <tr>
          <td>
            <code>grinder.useConsole</code>
          </td>

          <td>Set to <code>false</code> to set the agent and worker
          processes not to use the console.</td>

          <td>true</td>
	</tr>

        <tr>
          <td>
            <code>grinder.reportToConsole.interval</code>
          </td>

          <td>The period at which each process sends updates to the
          console. This also controls the frequency at which the data
          files are flushed.</td>

          <td>500 ms</td>
	</tr>

        <tr>
          <td>
            <code>grinder.initialSleepTime</code>
          </td>

          <td>The maximum time in milliseconds that each thread waits
          before starting. Unlike the sleep times specified in
          scripts, this is varied according to a flat random
          distribution. The actual sleep time will be a random value
          between 0 and the specified value. Affected by
          <code>grinder.sleepTimeFactor</code>, but not
          <code>grinder.sleepTimeVariation</code>.</td>
  
          <td>0 ms</td>
	</tr>

        <tr>
          <td>
            <code>grinder.sleepTimeFactor</code>
          </td>

          <td> Apply a factor to all the sleep times you've specified,
          either through a property of in a script. Setting this to
          <code>0.1</code> would run the script ten times as fast.</td>

          <td>1</td>
        </tr>

        <tr>
          <td>
            <code>grinder.sleepTimeVariation</code>
          </td>

          <td>The Grinder varies the sleep times specified in scripts
          according to a Normal distribution. This property specifies
          a fractional range within which nearly all (99.75%) of the
          times will lie. E.g., if the sleep time is specified as 1000
          and the sleepTimeVariation is set to <code>0.1</code>, then
          99.75% of the actual sleep times will be between 900 and
          1100 milliseconds.</td>

          <td>0.2</td>
        </tr>

        <tr>
          <td>
            <code>grinder.logProcessStreams</code>
          </td>

          <td>Set to <code>false</code> to disable the logging of
          output and error steams for worker processes. You might want
          to use this to reduce the overhead of running a client
          thread.</td>

          <td>true</td>
        </tr>

        <tr>
          <td>
            <code>grinder.recordTime</code>
          </td>

          <td>Set to <code>false</code> to disable reporting of <a
          href="site:development/timing">timing information</a>;
          other statistics are still reported.</td>

          <td>true</td>
	</tr>

      </table>
    </section>

    <section>
      <title>Specifying properties on the command line</title>

      <p>You can also specify these properties as Java system
      properties in the agent command line. For example, on UNIX
      systems the following command line can be used to generate log
      directories based on the current date.</p>

<source>
java -Dgrinder.logDirectory="log/$(date +%y%m%d)" net.grinder.Grinder
</source>
    </section>

  </section>
</body>
</document>
