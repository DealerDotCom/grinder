<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">

<document>
<header>
  <title>Getting started</title>
</header>

<body>
  <note>This section takes a top down approach to The Grinder. If you
  are happy figuring things out for yourself and want to get your
  hands dirty, you might like to read <a href="#howtostart">How do I
  start The Grinder?</a> and then jump to the <a
  href="site:script-gallery">Script Gallery</a>.</note>

  <section>
    <title>The Grinder processes</title>

    <p>The Grinder is a framework for running test scripts across a
    number of machines. The framework is comprised of three types of
    <em>process</em> (or program). <em>Worker processes</em>,
    <em>agent processes</em>, and the <em> <a
    href="site:console">console</a></em>. The responsibilities of
    each of the process types are:</p>

    <ul>
      <li>
        <strong>Worker processes</strong>
        <ul>
          <li>Interpret Jython test scripts and perform tests using a
          number of <em>worker threads</em></li>
        </ul>
      </li>

      <li>
        <strong>Agent processes</strong>
        <ul>
          <li>Manage worker processes</li>
        </ul>
      </li>

      <li>
        <strong>The console</strong>
        <ul>
          <li>Coordinate the other processes</li>
          <li>Collate and display statistics</li>
          <li>Script editing and distribution</li>
        </ul>
      </li>
    </ul>

    <p>As The Grinder is written in Java, each of these processes is a
    Java Virtual Machine (JVM).</p>

    <figure src="../images/processes.png" width="600" height="507"
    alt="The Grinder processes"/>

    <p>For heavy duty testing, you start an agent process on each of
    several load injector machines. The worker processes they launch can be
    controlled and monitored using the console. There is little reason
    to run more than one agent on each load injector, but if you can if
    you wish.</p>
  </section>

  <section>
    <title>Tests and test scripts</title>

    <p>A <em>test</em> is a unit of work against which statistics are
    recorded. Tests are uniquely defined by
    a <em>test number</em> and also have a <em>description</em>.
    Users specify which tests to run using a Jython <a
    href="site:scripts-intro">test script</a>.
    If you wish your scripts can report many different actions (e.g.
    different web page requests) against the same test, The Grinder
    will aggregate the results.</p>

    <p>The script is executed many times in a typical testing
    scenario. Each worker process has a number of worker threads, and
    each worker thread calls the script a number of times. A single
    execution of a test script is called a <em>run</em>.</p>

    <p>You can write scripts for use with the Grinder by hand. There are a
    number of examples of how to do this in the
    <a href="site:script-gallery">Script Gallery</a>. See the
    <a href="site:scripts/scripts-intro">Scripts</a> section for more details
    on how to create scripts.</p>

    <p>If you are creating a script to test a web site or web application, you
    can use the
    <a href="site:g3/getting-started/tcpproxy/HTTPPluginTCPProxyFilter">
    TCPProxy</a> to record a browser session as a script.</p>
  </section>

  <section>
    <title>Network communication</title>

    <p>Each worker process sets up a network connection to the
    console to report statistics. Each agent process sets up a
    connection to the console to receive commands, which it passes on
    to its worker processes. The console listens for both types of
    connection on a particular address and port. By default, the
    console listens on port <code>6372</code> on all local network
    interfaces of the machine running the console.</p>

    <p>If an agent process fails to connect to the console, or the
    <code>grinder.useConsole</code> property is <code>false</code>,
    the agent will continue independently without the console and
    automatically will start its worker processes. The worker
    processes will run to completion and not report to the
    console. This can be useful when you want to quickly try out a test
    script without bothering to start the console. </p>

    <note>To change the console addresses, set the
    <code>grinder.consoleHost</code> and
    <code>grinder.consolePort</code> properties in the <a
    href="site:g3/getting-started/properties"><code>grinder.properties</code></a>
    file before starting The Grinder agents. The values must match those specified
    in the console options dialog.</note>
  </section>

  <section>
    <title>Output</title>

    <p>Each worker process writes logging information to a file called
    <code>out-host-n.log</code>, where <code> host</code> is the
    machine host name and <code>n</code> is the worker process number.
    Errors are written to <code>error-host-n.log</code>. If no errors
    occur, an error file will not be created.</p>

    <p>Data about individual test invocations is written into a file called
    <code>data-host-n.log</code> that can be imported into a
    spreadsheet tool such as Microsoft Excel<sup>TM</sup> for further
    analysis. The data file is the only place where information about
    individual tests is recorded; the console displays only aggregate
    information.</p>

    <p>The final statistics summary (in the <code>out-*</code> files
    of each process) looks something like this:</p>

<source>
Final statistics for this process:

              Successful
              Tests         Errors        Mean Test    Test Time
                                          Time (ms)    Standard
                                                       Deviation
                                                       (ms)

Test 0        25            0             255.52       22.52
Test 1        25            0             213.40       25.15
Test 2        25            0             156.80       20.81         "Image"
Test 3        25            0             90.48        14.41
Test 4        25            0             228.68       23.97         "Login page"
Test 5        25            0             86.12        12.53         "Security check"
Test 6        25            0             216.20       8.89
Test 7        25            0             73.20        12.83
Test 8        25            0             141.92       18.36
Test 9        25            0             104.68       19.86         "Logout page"

Totals        250           0             156.70       23.32
</source>

    <p>The console has a dynamic display of similar information
    collected from all the worker processes. Plug-ins and advanced test
    scripts can provide additional statistics; for example, the HTTP plug-in
    adds a statistic for the content length of the response body.</p>

    <p>Each test has one of two possible outcomes:</p>

    <ol>
      <li>Success. The number of <em>Successful Tests</em> for that
      test is incremented The time taken to perform the test is added
      to the <em>Total</em>.</li>

      <li>Error. The execution of a test raised an exception. The
      number of <em>Errors</em> for the test is incremented. The time taken
      is discarded.</li>
    </ol>

    <p>The <em>Total</em>, <em>Mean</em>, and <em>Standard Deviation</em>
    figures are calculated based only on successful tests.</p>
  </section>

  <section id="howtostart">
    <title>How do I start The Grinder?</title>

    <p>Its easy:</p>

    <ol>
      <li>Create a <a
      href="site:g3/getting-started/properties"><code>grinder.properties</code></a> file.
      This file specifies general control information (how the worker
      processes should contact the console, how many worker processes
      to use, ..), as well as the name of the Jython script that will
      be used to run the tests.<p/></li>

      <li>Set your <code>CLASSPATH</code> to include the
      <code>grinder.jar</code> file which can be found in the
      <code>lib</code> directory.<p/></li>

      <li>Start the console on one of the test machines:
<source>
java net.grinder.Console
</source></li>

      <li>For each test machine, do steps 1. and 2. and start an agent
      process:
<source>
java net.grinder.Grinder
</source>
        <p>You can also specify an explicit properties file as the
        first argument. For example:</p>

<source>
java net.grinder.Grinder myproperties
</source>
      </li>
    </ol>

    <p>The console does not read the <code>grinder.properties</code>
    file. It has its own options dialog (choose the
    <em>File/Options</em> menu option) which you should use to set the
    communication addresses and ports to match those in the
    <code>grinder.properties</code> files. The <a
    href="site:console/process-controls">console controls</a> can be
    used to trigger The Grinder test scenario. Each agent process then
    creates child worker processes to do the work.</p>

    <p>As the worker processes execute, they dynamically inform the
    console of the tests in the test script. If you start the console
    after the agent process, you should press the <em>Reset
    processes</em> button. This will cause the existing worker
    processes to exit and the agent process to start fresh worker
    processes which will update the console with the new test
    information.</p>

    <p>Included below are some sample shell scripts, for both unix/linux and windows,
    for starting grinder agents, its console, and the HTTPProxy.</p>

    <p><strong>Windows:</strong></p>
    <ul>
     <li>setGrinderEnv.cmd:
<source>
set GRINDERPATH=<em>(full path to grinder install directory)</em>
set GRINDERPROPERTIES=<em>(full path to grinder.properties)</em>\grinder.properties
set CLASSPATH=%GRINDERPATH%\lib\grinder.jar;%CLASSPATH%
set JAVA_HOME=<em>(full path to java install directory)</em>
PATH=%JAVA_HOME%\bin;%PATH%
</source>
     </li>
     <li>startAgent.cmd:
<source>
call <em>(path to setGrinderEnv.cmd)</em>\setGrinderEnv.cmd
echo %CLASSPATH%
java -cp %CLASSPATH% net.grinder.Grinder %GRINDERPROPERTIES%
</source>
     </li>
     <li>startConsole.cmd:
<source>
call <em>(path to setGrinderEnv.cmd)</em>\setGrinderEnv.cmd
java -cp %CLASSPATH% net.grinder.Console
</source>
     </li>
     <li>startProxy.cmd:
<source>
call <em>(path to setGrinderEnv.cmd)</em>\setGrinderEnv.cmd
java -cp %CLASSPATH% net.grinder.TCPProxy -console -http > grinder.py
</source>
     </li>
    </ul>

    <p><strong>Unix:</strong></p>
     <ul>
      <li>setGrinderEnv.sh:
<source>
#!/usr/bin/ksh
GRINDERPATH=<em>(full path to grinder install directory)</em>
GRINDERPROPERTIES=<em>(full path to grinder.properties)</em>/grinder.properties
CLASSPATH=$GRINDERPATH/lib/grinder.jar:$CLASSPATH
JAVA_HOME=<em>(full path to java install directory)</em>
PATH=$JAVA_HOME/bin:$PATH
export CLASSPATH PATH GRINDERPROPERTIES
</source>
      </li>
      <li>startAgent.sh:
<source>
#!/usr/bin/ksh
. <em>(path to setGrinderEnv.sh)</em>/setGrinderEnv.sh
java -cp $CLASSPATH net.grinder.Grinder $GRINDERPROPERTIES
</source>
      </li>
      <li>startConsole.sh:
<source>
#!/usr/bin/ksh
. <em>(path to setGrinderEnv.sh)</em>/setGrinderEnv.sh
java -cp $CLASSPATH net.grinder.Console
</source>
      </li>
      <li>startProxy.sh:
<source>
#!/usr/bin/ksh
. <em>(path to setGrinderEnv.sh)</em>/setGrinderEnv.sh
java -cp $CLASSPATH net.grinder.TCPProxy -console -http > grinder.py
</source>
      </li>
     </ul>
  </section>

  <section id="howtosetup">
    <title>How should I set up a project structure for The Grinder?</title>
    <p>Well the short answer is however works best for you. Many people will already know how they want to set up
    their directory structure and will have no issue implementing The Grinder as one of their many tools. For those
    looking for a little guidance it is worth asking yourself questions like:</p>
    <ul>
      <li>How many projects will I be working on?</li>
      <li>Will I need to revisit projects from time to time?</li>
      <li>Do I need repeatability?</li>
      <li>Is this a shared implementation?</li>
      <li>...etc.</li>
    </ul>
    <p>Below is given an example of a directory structure for setting up The Grinder.</p>
<source>
.
`- <strong>Grinder</strong>
    |
    |-- <strong>bin</strong>
    |   |-- setGrinderEnv.sh/cmd
    |   |-- startAgent.sh/cmd
    |   |-- startConsole.sh/cmd
    |   `-- startProxy.sh/cmd
    |
    |-- <strong>engine</strong>
    |   |-- grinder-3.0-beta32
    |   |-- grinder-3.0
    |   `-- ...
    |
    |-- <strong>etc</strong>
    |   |-- grinder.properties
    |   `-- ...
    |
    |-- <strong>jvm</strong>
    |   |-- jdk1.3
    |   |-- jdk1.4.02
    |   `-- ...
    |
    |-- <strong>lib</strong>
    |   |-- jython2.1
    |   |-- jdom-1.0
    |   |-- xerces_2_6_0
    |   |-- xerces-2_6_2
    |   |-- oracle
    |   `-- ...
    |
    |-- <strong>logs</strong>
    |   `-- ...
    |
    `-- <strong>projects</strong>
        |-- website_project
        |   |-- httpscript.py
        |   |-- httpscript_tests.py
        |   `-- ...
        |
        |-- db_project
        |   |-- jdbc.py
        |   `-- ...
        |
        `-- ...
</source>
    <p>First off the <strong>bin</strong> directory has been created for storing executable files for the implementation.
    The sample start scripts from <a href="#howtostart"> "How do I start The Grinder?"</a> have been included in this directory.
    The <strong>engine</strong> directory has been created for storing the versions
    of The Grinder that may be used. Strictly speaking the versions of The Grinder could be stored under the <strong>lib</strong>
    directory but for this example The Grinder has been given its own directory. The <strong>etc</strong> directory has been created
    to store the configuration files for the implementation such as the grinder.properties file. The <strong>jvm</strong> directory has been
    created to store the various jdks and their versions that could be used in testing. The <strong>lib</strong> directory has been
    created to store the various third party libraries and their respective versions that projects may require. For example if you
    wanted to use the full set of <a href="site:g3/scripts/scripts-intro/jython-installation">libraries</a> which come with jython
    then this is the directory into which you would install. Remember to update your CLASSPATH with the libraries you require. The <strong>logs
    </strong> has been created to store the various logs that the grinder generates during its runs.The <strong>projects</strong>
    directory has been created to store the scripts to be run by The Grinder and organise them by project/body of work.</p>

    <p>The above example would be useful as a simple implementation for one person who works on one project at a time.
    As the number of projects grows, more people share the implementation, or projects need
    to be revisited with repeatability ensured, then it makes sense, in this example, to
    modularize the implementation around the projects. To do this simply create the <strong>bin</strong>, <strong>etc</strong> and <strong>logs</strong>
    directories under the respective projects like so:</p>
<source>
    |
    `-- <strong>projects</strong>
        |-- website_project
        |   |-- <strong>bin</strong>
        |   |   |-- setGrinderEnv.sh/cmd
        |   |   |-- startAgent.sh/cmd
        |   |   |-- startConsole.sh/cmd
        |   |   `-- startProxy.sh/cmd
        |   |-- <strong>etc</strong>
        |   |   |-- grinder.properties
        |   |   `-- ...
        |   |-- httpscript.py
        |   |-- httpscript_tests.py
        |   |-- <strong>logs</strong>
        |   |   `-- ...
        |   `-- ...
        |
        |-- db_project
</source>

   <p>Once this has been done the environment can be set to use the engine, jvm and libraries required by a particular project, rather
   than setting the environment for all the projects (as would happen in the simple implementation). This allows you, for example, to
   retain projects which were run using legacy versions of libraries and/or engine and re-run them at a later date with the same setup.
   Also different projects may require different versions of the same library which would have caused issues when using an implementation-wide
   CLASSPATH. The grinder.properties file can also be customised on a per project basis.</p>

   <p>Modularizing the implementation like this gives greater flexibility and repeatability and opens up the prospect of multiple
   people using the implementation concurrently.</p>
  </section>

</body>
</document>
