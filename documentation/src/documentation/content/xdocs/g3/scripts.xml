<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">

<document>
<header>
  <title>Scripts</title>
</header>
<body>

  <p>This section describes The Grinder 3 scripting API. If you've
  used The Grinder 2 for HTTP testing and you're not a programmer, you
  might be a bit daunted. Don't worry, its just as easy to record and
  replay HTTP scripts with The Grinder 3.</p>

  <section>
    <title>Jython and Python</title>

    <p>The Grinder 3 scripting engine is Jython - the Java
    implementation of Python. Python is powerful, popular and easy on
    the eye. If you've never seen any Python before, don't panic. Take
    a look at the <a href="site:script-gallery">script gallery</a> and
    Richard Perks' <a href="site:tutorial">tutorial</a> to get a taste
    of what its like. There are plenty of resources on the web, here
    are a few of them to get you started:</p>

    <ul>
      <li><a href="ext:jython">The Jython home page</a></li>
      <li><a href="ext:python">The Python language web site</a></li>
    </ul>

    <p>I recommend the <a href="ext:amazon/jython-essentials">Jython
    Essentials</a> book; you can read the <a
    href="ext:oreilly/jython-essentials-c1">introductory chapter</a>
    for free.</p>
  </section>

  <section>
    <title>Scripting for The Grinder</title>

    <section>
      <title>Script structure</title>

      <p>Scripts must conform to a few conventions in order to work
      with The Grinder framework. I'll lay the rules out in fairly dry
      terms before proceeding with an example. Don't worry if this
      makes no sense to you at first, the examples are much easier to
      comprehend.</p>

      <ol>
        <li>
          <strong>Scripts must define a class called
          <code>TestRunner</code></strong>

          <p>When a worker process starts up it runs the test script
          once. The test script must define a class called
          <code>TestRunner</code>. The Grinder engine then creates an
          instance of <code>TestRunner</code> for each worker thread.
          A thread's TestRunner instance can be used to store
          information specific to that thread.</p>

          <note>Although strongly recommended, strictly
          <code>TestRunner</code> doesn't need to be a class. See the
          <a href="site:script-gallery/helloworldfunctions">Hello
          World with Functions</a> example.</note>
        </li>

        <li>
          <strong>The <code>TestRunner</code> instance must be
          callable</strong>

          <p>A Python object is callable if it defines a
          <code>__call__</code> method. Each worker thread performs a
          number of <em>runs</em> of the test script, as configured by
          the property <code>grinder.runs</code>. For each run, the
          worker thread calls its <code>TestRunner</code>; thus the
          <code>__call__</code> method can be thought of as the
          definition of a run.</p>
        </li>

        <li>
          <strong>The test script can access services through the
          <code>grinder</code> object</strong>

          <p>The engine makes an object called <code>grinder</code>
          available for the script to import. It can also be imported
          by any modules that the script calls. This is an instance of
          the <a
          href="script-javadoc/net/grinder/script/Grinder.ScriptContext.html">Grinder.ScriptContext</a>
          class and provides access to context information (such as
          the worker thread ID) and services (such as logging and
          statistics).</p>
        </li>
      </ol>
    </section>

    <section>
      <title>Canonical test script structure</title>

      <p>This is an example of a script that conforms to the rules
      above. It doesn't do very much - every run will log <em>Hello
      World</em> to the output log.</p>

<source>
from net.grinder.script.Grinder import grinder

# An instance of this class is created for every thread.
class TestRunner:
    # This method is called for every run.
    def __call__(self):
        # Per thread scripting goes here.
        grinder.logger.output("Hello World")
</source>
    </section>
  <section>
      <title>Automatically generating scripts</title>
    <p>If you are creating a script for a website or web application, you can use the <a href="site:g3/getting-started/tcpproxy/HTTPPluginTCPProxyFilter">TCPProxy</a> to generate an HTTPPlugin script
      suitable for use with The Grinder.</p>
  </section>
  </section>

  <section id="tests">
    <title>Tests</title>

    <p>Although our simple test script can be used with The Grinder
    framework and can easily be started in many times in many worker
    processes on many machines, it doesn't report any statistics. For
    this we need to create some tests. A <a
    href="script-javadoc/net/grinder/script/Test.html">Test</a> has a
    unique test number and description. If you are using the <a
    href="site:console">console</a>, it will automatically update to
    display new <code>Test</code>s as they are created.</p>

    <p>Let's add a <code>Test</code> to our script.</p>

<source>
from net.grinder.script import Test
from net.grinder.script.Grinder import grinder

# Create a Test with a test number and a description.
test1 = Test(1, "Log method")

class TestRunner:
    def __call__(self):
        log("Hello World")
</source>

    <p>Here we have created a single <code>Test</code> with the test
    number <em>1</em> and the description <em>Log method</em>. Note
    how must import the <code>Test</code> class in a similar manner to
    Java. We've also explicitly imported the <code>grinder</code>
    object, this is good practice as it allows our script to be called
    from other scripts as a Python <em>module</em>.</p>

    <p>Now the console knows about our <code>Test</code>, but we're
    still not using it to record anything. Let's record how long our
    <code>grinder.logger.output</code> method takes. To instrument the
    <code>grinder.logger.output</code> method we use our
    <code>Test</code> to wrap it with a proxy <em>wrapper</em>. The
    wrapper object looks exactly like the
    <code>grinder.logger.output</code> method and can be called in the
    same manner. If we call the wrapper the call will be delegated
    through to the <code>grinder.logger.output</code> method but
    additionally the time taken to do the call and the number of calls
    will be recorded and reported to the console.</p>

<source>
from net.grinder.script import Test
from net.grinder.script.Grinder import grinder

test1 = Test(1, "Log method")

# Wrap the log() method with our Test and call the result logWrapper.
logWrapper = test1.wrap(grinder.logger.output)

class TestRunner:
    def __call__(self):
        logWrapper("Hello World")
</source>

    <p>This is a fully functional test script that works within The
    Grinder framework and reports results to the console.</p>

    <p>You're not restricted to wrapping method calls. In fact, its
    more common to wrap objects. Here's an example using The Grinder's
    <a href="site:g3/plugins/http-plugin">HTTP plug-in</a>.</p>

<source>
# A simple example using the HTTP plugin that shows the retrieval of a
# single page via HTTP.

from net.grinder.script import Test
from net.grinder.script.Grinder import grinder
from net.grinder.plugin.http import HTTPRequest

test1 = Test(1, "Request resource")
request1 = test1.wrap(HTTPRequest())

class TestRunner:
    def __call__(self):
        result = request1.GET("http://localhost:7001/")
</source>

  </section>

  <section>
    <title>The Grinder script API</title>

    <p>With what you've seen already you have the full power of Jython
    at your finger tips. You can use practically <em>any</em> Java or
    Python code in your test scripts.</p>

    <p>The Grinder script API can be used to access services from The
    Grinder. The <a href="script-javadoc/index.html">Javadoc</a>
    contains full information on all the packages, classes and
    interfaces that make up the core API, as well as additional
    packages added by the shipped plug-ins. This section provides
    overview information on various areas of the API. See also the <a
    href="site:g3/plugins/http-plugin">HTTP plugin documentation</a>.</p>

    <dl>
      <dt><strong>The <a href="script-javadoc/net/grinder/script/package-summary.html">net.grinder.script</a> package</strong></dt>

      <dd>
        <p>An instance of <a
        href="script-javadoc/net/grinder/script/Grinder.ScriptContext.html">Grinder.ScriptContext</a>
        called <code>grinder</code> is automatically available to all
        scripts. This object provides access to context information
        and acts a starting point for accessing other services. The
        instance can be explicitly imported from other Python modules
        as <code>net.grinder.script.Grinder.grinder</code>.</p>

        <p>We have described the use of the <a
        href="script-javadoc/net/grinder/script/Test.html">Test</a>
        class <a href="#tests">above</a>.</p>

        <p>The <a
        href="script-javadoc/net/grinder/script/Statistics.html">Statistics</a>
        interface allows scripts to query whether tests where
        successful and obtain statistic values such as test
        time of the last test. The interface can also be used to
        modify or set a tests statistics before they are sent to the
        log and the console.</p>
      </dd>

      <dt><strong>The <a
      href="script-javadoc/net/grinder/common/package-summary.html">net.grinder.common</a>
      package</strong></dt>

      <dd>
        <p>This package contains common interfaces and utility classes
        that are used throughout The Grinder and that are also useful
        to scripts.</p>
      </dd>

      <dt><strong>The <a
      href="script-javadoc/net/grinder/statistics/package-summary.html">net.grinder.statistics</a>
      package</strong></dt>

      <dd>
        <p>Scripts can use this package to report custom statistics
        and to register additional views of standard and custom
        statistics.</p>

  <p>Each statistic has a unique index object and a name. The
  index objects are used with the <a
  href="script-javadoc/net/grinder/script/Statistics.html">Statistics</a>
  interface and the names can be used in expressions (see <a
  href="script-javadoc/net/grinder/statistics/ExpressionView.html">ExpressionView</a>).
  Statistics can either be <em>long</em> integer values or
  <em>double</em> floating-point values.</p>

  <p>The standard long statistics used by The Grinder are:</p>

  <ul>
    <li><code>errors</code></li>
    <li><code>untimedTests</code></li>
    <li><code>period</code></li>
  </ul>

        <p>Additionally, there are five long statistics that scripts
        and custom plug-ins can use for their own purposes,
        <code>userLong0</code>,<code>userLong1</code>, ...
        <code>userLong4</code>.
  </p>

  <p>The standard double statistics used by The Grinder are:</p>

  <ul>
      <li><code>peakTPS</code></li>
  </ul>

  <p>Additionally, there are five double statistics for use by
  scripts and custom plugins,
  <code>userDouble0</code>,<code>userDouble1</code>, ...
  <code>userDouble4</code>.
  </p>

  <p>There is a special type of index object for <em>sample</em>
  statistics. Sample statistics are the result of a series of
  sample values. The values can be either <em>long</em> s or
  <em>double</em>s. Sample statistics have three attribute
  values that can be read: the <em>count</em> (number of
  samples), <em>sum</em> (total of all sample values), and
  sample <em>variance</em>. The only way for a script to query
  these attributes is through an <a
  href="script-javadoc/net/grinder/statistics/ExpressionView.html">ExpressionView</a>,
  using the appropriate expression function (e.g.
  <em>count()</em>).</p>

        <p><a
        href="script-javadoc/net/grinder/statistics/ExpressionView.html">ExpressionView</a>s
        allow individual statistics to be combined in simple
        expressions. For example <code>(/ errors (+ timedTests
        untimedTests))</code> gives the ratio of errors to successful
        tests. New views can be registered using the
        <code>grinder</code> <a
        href="script-javadoc/net/grinder/script/Grinder.ScriptContext.html">Grinder.ScriptContext</a>
        object and automatically appear in the console and the data
        file.</p>

  <p>All the statistics displayed in the console are aggregates
  (totals or averages) of a number of tests received in the
  appropriate period. The reason for this is efficency. The
  Grinder would not perform or scale if every data point was
  transfered back to the console. Custom statistics can be added
  to console views using script context's <a
  href="script-javadoc/net/grinder/script/Grinder.ScriptContext.html#registerSummaryStatisticsView(net.grinder.statistics.StatisticsView)">registerSummaryStatisticsView</a>
  method.</p>

  <p>The only place per-test statistics are available is in the
  process <code>data_*</code> files. Custom statistics can be
  added to data files using script context's <a
  href="script-javadoc/net/grinder/script/Grinder.ScriptContext.html#registerDetailStatisticsView(net.grinder.statistics.StatisticsView)">registerDetailStatisticsView</a>
  method.</p>

      </dd>
    </dl>
  </section>

  <section id="jython-installation">
    <title>The Jython distribution and installation</title>

    <p>The Grinder is shipped with a version of Jython but does not
    package the Jython distribution of the standard Python library. If
    you want to use the standard library, or if you want to use a
    different version of Jython, obtain and install Jython and add the
    installation's <code>jython.jar</code> to the start of the
    <code>CLASSPATH</code> used to launch The Grinder.</p>

    <p>Jython picks up user and site preferences from several sources
    (see <a
    href="ext:jython/registry">http://www.jython.org/docs/registry.html</a>).
    A side effect of adding the installed <code>jython.jar</code> to
    the start of the <code>CLASSPATH</code> is that
    <code>python.home</code> can be correctly determined and the
    installed registry file will be used.</p>

    <p>A useful thing that you can set in the registry is
    <code>python.cachedir</code>. This specifies a working directory
    which Jython uses to store byte compiled python code. If you do
    not have your own installed version of Jython in the
    <code>CLASSPATH</code>, the working directory will be created in
    the directory which you run The Grinder. This is fine for most
    casual users; if you are are terribly worried about preserving
    disk space, read the information on the Jython site.</p>
  </section>
</body>
</document>
