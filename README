The Grinder
Copyright (C) 2001 Paco Gómez
Copyright (C) 2001 Philip Aston

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

Please see the file COPYING for details of the General Public License.


What is it?
***********

The Grinder is a simple, pure Java load-testing framework released
under the GNU Public License. It was originally developed for the book
"Professional Java 2 Enterprise Edition with BEA WebLogic Server" by
Paco Gómez and Peter Zadrozny.

Test client code is written in the form Java "plug-ins". Sample
plug-ins for testing HTTP services are provided. It is particularly
suitable for testing BEA WebLogic Server based applications.

A JUnit plugin is also supplied. This opens up interesting
possibilities for bake testing Java code to discover race conditions
and other bugs.


Where do I get it?
******************

The Grinder's home is currently at

	http://sourceforge.net/projects/grinder/

There are also some mailing lists you might like to join.


What else do I need?
********************

To run The Grinder:

  JDK 1.3

and optionally:

  JSSE 1.0.2			for SSL support
  Apache Jakarta Regexp 1.2	for the TCPSniffer HTTP plugin 
  Apache Jakarta Ant 1.2	to build The Grinder from source
  JUnit 3.4			to test The Grinder itself


How do I build it?
******************

See the instructions in build.xml.


How do I use it?
****************

Its easy:

	1. Set your classpath to include the grinder.jar file in the
	   lib directory.

	2. Change to a test directory, and set up a grinder.properties
	   file which defines the test you want to perform. See the
	   examples directory for inspiration.

	3. Say
		java net.grinder.Grinder

If you want to use the Console, (and you probably do), tweak the
following properties

	grinder.receiveConsoleSignals
	grinder.multicastAddress
	grinder.multicastPort

	grinder.reportToConsole
	grinder.console.multicastPort

and say
	java net.grinder.Console


You can also specify an explicit properties file to both the Grinder
and the Console as the first argument. For example:

	java net.grinder.Grinder myproperties


The output
**********

The final statistics summary looks something like this:

 Final statistics for this process:
            Successful
            Transactions  Errors     Abortions  Total (ms) Average (ms)  
 Test 0     100           0          0          30         0.30
 Test 1     100           0          0          20         0.20
 Test 2     100           0          0          0          0.00
 Test 3     100           0          0          10         0.10
 Test 4     100           0          0          10         0.10
 Test 5     100           0          0          10         0.10
 Test 6     100           0          0          0          0.00
 Test 7     100           0          0          0          0.00
 Test 8     100           0          0          50         0.50
 Test 9     100           0          0          30         0.30

Each test has one of 3 possible outcomes:

	1. Success. The number of Successful Transactions for that test is
	   incremented The time taken to perform the test is added to
	   the Total.

	2. Error - "false" is returned from doTest(). The exact
	   interpretation of this depends on the plugin. The number of
	   Errors for the test is incremented.

	3. Abortion. The plugin chooses to abort the cycle or thread.
	   Again, when this might happens depends on the plugin. The
	   number of Abortions for the test is incremented.

The Total and Average figures are calculated based only on successful
transactions.


I don't get it, help!
*********************

Try asking at grinder-use@lists.sourceforge.net


How do I fix it?
****************

Please send bug fixes and enhancements you make to
grinder-development@lists.sourceforge.net.

BEA keeps me very busy so the timeliness and quality of any email
support I provide will vary.


What can I set in grinder.properties?
*************************************

[This is not complete - volunteer work required!]

    grinder.processes	-	The number of child VM processes to start.

    grinder.threads	-	The number cycles of the threads each 
				process spawns.

    grinder.cycles	-	The number cycles of the test script
				each thread performs.

    grinder.jvm		-	Use an alternate JVM for child processes.

    grinder.jvm.path	-	Specifies the java executable used for
				the child JVMs. Defaults to "java" so
				you do not need to specify this if
				your path is sensible.

    grinder.jvm.classpath -	Use to adjust the classpath used for
				the child VMs. Anything specified here
				will be prepended to the classpath
				used to start the grinder itself.

    grinder.jvm.arguments -	Additional arguments to child JVM's.

    grinder.hostID	-	Override the "host" string used in log
   				filenames and logs. Defaults to the
    				host name.

    grinder.appendLog	-	Append to, rather than overwrite,
				existing log files.

    grinder.receiveConsoleSignals -
				Set to true to respond to Console
				"start" and "stop" signals. This will
				mean that the test cycles will not
				start until a Console signal is
				recieved.

    grinder.reportToConsole -	Set to true to send stats to the Console.

    grinder.multicastAddress -  The multicast address to use for
				communication between the grinder
				processes and the Console.
				(See "What do I need to do to set up
				multicast?" below).

    grinder.multicastPort -     The multicast port to use for communication
				from the Console to the grinder processes.

    grinder.console.multicastPort -
				The multicast port to use for communication
				from the grinder processes to the Console.

    grinder.reportToConsole.interval -
				The period at which each process sends
				updates to the Console (default 500
				ms).

    grinder.thread.beginCycleSleepTime	-
				The time in milliseconds to wait before
				beginning each cycle.

    grinder.thread.sleepTime -	The time in milliseconds to wait
				between individual tests.

    grinder.thread.sleepTimeFactor -
				Apply a factor to all the sleep times
				you've specified. E.g., setting this
				to 0.1 would run the script at ten times
				te speed.

    grinder.thread.sleepTimeVariation -
				The Grinder varies the specified sleep
				times according to a Normal
				distribution. This property specifies
				a fractional range within which nearly
				all (99.75%) of the times will lye.
				E.g., if the sleep time is specified
				as 1000 and the sleepTimeVariation is
				set to 0.1, then 99.75% of the actual
				sleep times will be between 9900 and
				11000 milliseconds.

    grinder.plugin	-	The plugin class to use. Currently each
				script uses a single plugin.

    grinder.plugin.parameter -	Prefix for properties interpreted by
				the plugin. See the documentation for
				the HTTP plugin below for examples.

    grinder.test0	- 	Prefix for test 0 properties. Test 1 
				properties have a prefix of
				"grinder.test1", and so on. The
				tests are run in numerical order.

    grinder.test0.description -	Information string used in the log
			 	files. Will be used in the
				Console in the future.

    grinder.test0.sleepTime -	Override grinder.thread.sleepTime
				for a specific test.

    grinder.test0.parameter -	Prefix for test specific properties
			 	interpreted by the plugin. See the
			 	documentation for
				the HTTP plugin below for examples.

    grinder.logProcessStreams - Set to false to disable the logging of
				standard out and standard error steams
				for individual Grinder processes. Default
				is true.


What can I set in grinder.properties for the HTTP plugin?
*********************************************************

    grinder.plugin.parameter.useCookies -
				Set to false to disable cookie
				handling (it defaults to true).

    grinder.plugin.parameter.useCookiesVersionString -
				Set to false to remove $Version string
				from cookies (it defaults to true).
				This is to work around broken (?)
				JRun 2.3.3. behavour.

    grinder.plugin.parameter.followRedirects -
				Set to true to automatically follow
				redirects, so you don't have to have
				additional URL's in you scripts. The
				default is false.

				You should always set this to false for
				TCPSnffer generated scripts.

				If you are using WebLogic Server and
				Web Application form-based
				authentication you leave this property
				set to false. This is because a
				redirect request that follows
				authentication contains a key cookie -
				setting the property to true prevents
				the cookie from being picked up by the
				plugin.

    grinder.plugin.parameter.stringBean -
				Fully qualified classname of a Java
				bean that can provide dynamic strings
				for URL's and POST data. See "What's a
				String Bean?" below.

    grinder.test0.parameter.url -
				The URL to call. The HTTP GET method
				is used unless
			 	grinder.test0.parameter.post is
			 	specified.

    grinder.test0.parameter.ok	-
				Fail if the returned page doesn't
			 	contain this string.

    grinder.test0.parameter.post -
				Specify a file containing POST data to
			 	send.

    grinder.test0.parameter.ifModifiedSince -
				This appears in the HTTP
			 	"If-Modified-Since" request header,
			 	allowing the grinder to simulate the
			 	a browser's caching of pages. Its value
				should be a date of the form
				Sat, 06 Jan 2001 13:36:39 GMT.


What's a String Bean?
*********************

When using the HTTP plugin, it is often necessary to parametrise parts
of URL's and POST data. The easy way to do this is to use a "String
Bean" - a Java Bean that returns Strings from its "get" methods.

For example, supporse you wanted to modify the URL
"http://myhost/test.jsp?n=1" such that n is set to a random number
each time? Easy! Here's how.

Write a simple bean:

  // MyStringBean.java
  package mystuff;

  public class MyStringBean {
    private Random m_random = new Random();

    public String getRandomInteger() {
      return Integer.toString(m_random.nextInt());
    }
  }

Compile this and put it in your classpath. Then alter your
grinder.properties to include this line:

  grinder.plugin.parameter.stringBean=mystuff.MyStringBean

Alter the test URL parameter as follows:

  grinder.test0.parameter.url=http://myhost/test.jsp?n=<getRandomInteger>


The <beanMethodName> syntax can be used in any URL string or POST data
file. It must correspond to a public method of the string bean that
takes no parameters and returns a String.

Each string bean instance is instantiated per thread, and maintains
its state between invocations. If your bean needs additional
information regarding the test lifecycle (for example, to reset a
counter and the beginning of a cycle), it can implement the
net.grinder.http.plugin.StringBean interface. See the examples in
net.grinder.http.plugin.example.


How do I use the HTTPS plugin?
******************************

1) Install JSSE1.0.2. See
   http://java.sun.com/products/jsse/INSTALL.html

2) In your grinder.properties, use the HttpsPlugin rather than
   HttpPlugin:

	grinder.plugin=net.grinder.plugin.http.HttpsPlugin

3) You can then use https:// in your URLs

	grinder.plugin.parameter.url0=https://localhost:7002/snoop
	grinder.plugin.parameter.ok0=Requested URL:

4) If you want two-way authentication, add the following lines

	grinder.plugin.parameter.clientCert=./philclient.p12
	grinder.plugin.parameter.clientCertPassword=acrobat

	(export p12 from netscape)

The JSSE SSL implementation isn't quick. This should be taken into
account when comparing round trip times, as a compiled browser version
is likely to be a *lot* faster.


What is the TCPSniffer and how do I use it?
*******************************************

The TCPSniffer is a proxy that you can place between in a TCP stream.
It filters the request and response streams, sending the results to
stdout. You can control its behaviour by specifying different filters.

Whilst its very useful in its own right, its main purpose as far as
the Grinder goes is to automatically generate scripts for the HTTP
plugin.

You invoke the sniffer with something like:

  CLASSPATH=/opt/grinder/lib/grinder.jar;
  CLASSPATH=$CLASSPATH:/opt/jakarta-regexp-1.2/jakarta-regexp-1.2.jar
  export CLASSPATH

  java net.grinder.TCPSniffer

Say "java net.grinder.TCPSniffer -?" to get a list of the command line
options.

To use it to generate a HTTP plugin script segment of a conversation
with a server on host "server", port "7001", you should say something
like:

  java net.grinder.TCPSniffer -httpPluginFilter -remoteHost server

  Initialising standard sniffer engine with the parameters:
     Request filter:  net.grinder.plugin.http.HttpPluginSnifferFilter
     Response filter: net.grinder.tools.tcpsniffer.NullFilter
     Local port:       8001
     Remote host:      server
     Remote port:      7001
  Engine initialised, listening on port 8001
  Starting engine

You should then point your browser at "localhost:8001" and exercise
the application.

You should obtain the Jakarta Regexp package from
http://jakarta.apache.org/. We don't include it with the Grinder
distribution due to the restrictions of the GPL, see
http://www.gnu.org/philosophy/license-list.html for details.


Using the HttpPluginSnifferFilter
*********************************

The output of the HttpPluginSnifferFilter looks like:

  java net.grinder.TCPSniffer -httpPluginFilter

  Initialising standard sniffer engine with the parameters:
     Request filter:  net.grinder.plugin.http.HttpPluginSnifferFilter
     Response filter: net.grinder.tools.tcpsniffer.NullFilter
     Local port:       8001
     Remote host:      localhost
     Remote port:      7001
  Engine initialised, listening on port 8001
  Starting engine
  grinder.test0.sleepTime=11336
  grinder.test0.parameter.url=http://localhost:7001/
  grinder.test1.sleepTime=12168
  grinder.test1.parameter.url=http://localhost:7001/lah.html
  grinder.test2.sleepTime=411
  grinder.test2.parameter.url=http://localhost:7001/test.gif
  grinder.test3.sleepTime=4786
  grinder.test3.parameter.url=http://localhost:7001/lah.html
  grinder.test3.parameter.ifModifiedSince=Tue, 16 Jan 2001 16:26:42 GMT
  grinder.test4.sleepTime=311
  grinder.test4.parameter.url=http://localhost:7001/test.gif
  grinder.test4.parameter.ifModifiedSince=Mon, 06 Nov 2000 08:35:58 GMT

The script part of this is sent to the stdout stream, whereas the
information messages are sent to stderr. You can redirect the script
part to a file if you wish:

  java net.grinder.TCPSniffer -httpPluginFilter > myscript

The HttpPluginSnifferFilter does not produce a complete
grinder.properties script. Additionaly, the parsing of HTTP messages
probably contains bugs. Don't let this put you off, using the
HttpPluginSnifferFilter is a very quick way of doing 95% of a tedious
job.


How should I use the JUnit Plugin?
**********************************

Set grinder.plugin to "net.grinder.plugin.junit.JUnitPlugin" and set
the following plugin parameter property:

    grinder.plugin.parameter.testSuite -
				The fully qualified name of the JUnit
				Test Suite class.

The class can be anything you can normally pass to a JUnit TestRunner.
A quick summary: it can either have a method, "public static
junit.framework.Test suite()" which returns the TestSuite _or_ it can
define a number of tests methods which will be discovered through
introspection - the method names must begin with "test".

(Confusingly, it matters not whether the class directly implements
junit.framework.TestSuite; this is a JUnit thing, so take any
complaints there).

You can also set

    grinder.plugin.parameter.logStackTraces -
				Set to true to produce stack traces
				for failures and errors in the error
				log.

Why would you want to do use the JUnit plugin? Three possible reasons
spring to mind:

 - To write a simple test case around arbitrary Java code, rather than
   defining a new Grinder plugin. This is the recommended way to
   replace the functionallity of the old "TraderEJBPlugin". (As an
   added bonus you end up with some JUnit test cases which you can use
   to impresses your boss _and_ to bug people with tales of what an
   extreeeeme ...err.. doood you are).

 - To thrash the heck out of your code in an attempt to discover race
   conditions (bugs).

 - To investigate the statistical effects of subatomic particles
   passing through your hardware.

Looking for race conditions requires that each instance of the JUnit
tests should run against a common fixture - how to achieve in general
this is left as an exercise. Please send any useful patterns to
grinder-use@lists.sourceforge.net. Additionally, because The Grinder
currently runs each test cycle in the same order, most race conditions
will be hidden. The fix for this is to implement a test scheduler
abstraction, see TODO. Patches welcome.


The tests to run are automatically sucked out of the test suite class
- you shouldn't specify them individually in grinder.properties.
However, you can tweak with individual tests' sleep time as normal.
For example, if you want to wait a second before the 6th test in the
test suite, you should say

   grinder.test5.sleepTime=1000

JUnit has the concept of "Failures" (which occur due to assertions
failing) and "Errors" (which occur when tests throw exceptions). If a
test causes _either_ a Failure or an Error, the Grinder "Errors" count
for that test is incremented by one. Currently running tests should
not cause Grinder "Abortions".


What do I need to do to set up multicast?
*****************************************

You must set up multicast if you want to use the Console. It is used
to send signals from the Console to the Grinder processes (start,
stop) and to send statistics reports from the Grinder processes to the
Console.

For most modern TCP stacks, e.g Windows 95/98/NT, Linux, multicast
works out of the box.

Under Linux, you may also need to set up the routing table. Try:

 $ route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0

Some Windows VPN clients (e.g Bay Networks Extranet) interfere with
multicast. You may need to disable them.


Tell me more about the Console controls?
****************************************

The process controls:

  The controls "Start processes" and "Stop processes" send signals to
  start and stop any Grinder processes that are currently listening.

The sample controls:

  There are a set of slider controls that determine the samples that
  the Console will capture. It is important to understand that these
  sliders control the Console behaviour _only_. For example, they do
  not adjust the frequency at which the Grinder processes report (see
  grinder.reportToConsole.interval for that). Additionally, the do not
  interact in any way with the process controls.

  The first slider controls the period at which the console will take
  a "sample". This involves adding up all the reports recieved over
  that sample interval and calculating the TPS as (number of
  transactions that occured)/(interval length). It is also the period
  at which the Console graphs and statistics are updated.

  By default, the Console discards the first non-zero sample period,
  and starts updating the display and calcluating totals from the
  second sample. A non-zero sample period is one in which an update
  from a Grinder process was received. You can adjust how many
  non-zero sample periods the Console ignores before starting capture
  with the second slider.

  The third slider allows you to adjust how many samples the Console
  will collect before stopping capture.

  You can also manually start and stop the sampling with the "Capture
  statistics" and "Stop capture" controls. Using the "Capture
  statistics" button resets all the captured statistics and "arms" the
  Console to ignore the specified number of non-zero samples before
  starting capture again.

  Finally, the "Summary" control displays a table of results, similar
  to what the individual Grinder processes produce but based on
  statistics collected from all of the processes over the sample
  period. In future we hope to add "File/Save" type functionality to
  save the results of a capture.


Can I run different test scripts against the same Console?
**********************************************************

Yes.

Whilst the Console reads the grinder.properties file to determine the
names of the tests, it is fairly decoupled from the Grinder processes.
It receives reports and updates the graph based on test number. Thus
it is possible to have different Grinder processes running scripts
with different test numbers (e.g. one process running tests 1 to 5 and
another running tests 6 to 10)., reporting to the same Console. You
would have to start the console against a dummy properties file that
contained all the tests (e.g 1 to 10).

This is definitely a hack at the moment. We plan to resolve this with
a much better Console/Grinder model in the Grinder 3. (James Bond will
return in ....).


Development goals
*****************

The Grinder should remain simple and Java based.

The Grinder should be useable with the standard JDK. For example, it
should not rely on WebLogic Server specific classes except for
optional WebLogic Server specific extensions. An exception to this
rule has been made for Jakarta Ant and Regexp because they are under
Free (unless you talk to RMS) licenses.

See the grinder-development list archives for further musings.
