The Grinder
Copyright (c) 2000 Paco Gomez
Copyright (c) 2000, 2001, 2002 Philip Aston
All rights reserved.

Additional contributions have been made by individuals listed in the
AUTHORS file supplied with this distribution. Each individual's claim
to copyright is asserted in the files to which they contributed.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.
    * Neither the names of the copyright holders nor the names of the
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


The Grinder includes Ronald Tschalär's HTTPClient library
(http://www.innovation.ch/java/HTTPClient/index.html). The HTTPClient
library is distributed under the GNU Lesser Public License. Under the
term 6 of the GNU Lesser Public License, The Grinder is a "work that
uses the Library". See doc/HTTPClient-license.txt for details of the
GNU Lesser Public License.

The Grinder includes software developed by the Apache Software
Foundation (http://www.apache.org/), specifically the Jakarta ORO
regular expression library. See doc/Jakarta-ORO-license.txt for
license details.



What is it?
***********

The Grinder is a pure Java load-testing framework that is freely
available under a BSD style open-source license. It was originally
developed for the book "Professional Java 2 Enterprise Edition with
BEA WebLogic Server" by Paco Gómez and Peter Zadrozny. Philip Aston
took ownership of the code and reworked it to create The Grinder 2.
Philip continues to enhance and maintain The Grinder.

Test client code is written in the form Java "plug-ins". Sample
plug-ins for testing HTTP services are provided. It is particularly
suitable for testing BEA WebLogic Server applications.

A JUnit plugin is also supplied. This opens up interesting
possibilities for bake testing Java code to discover race conditions
and other bugs.


Where do I get it?
******************

The Grinder's home is currently at

	http://grinder.sourceforge.net/

There are also some mailing lists you might like to join.


What else do I need?
********************

To run the Grinder:

  JDK 1.3, or equivalent

and optionally:

  JSSE 1.0.2			for SSL support
  Apache Jakarta Ant 1.4.1	to build the Grinder from source
  JUnit 3.7			to test the Grinder itself


These can be obtained from the following places.

 http://java.sun.com/products/jsse/
 http://jakarta.apache.org/ant/index.html
 http://sourceforge.net/projects/junit/


How do I build it?
******************

The Grinder is distributed pre-built so you can use it straight away.
The source code is provided too. If you want to rebuild it refer to
the instructions in build.xml.


How do I use it?
****************

Its easy:

	1. Set your classpath to include the grinder.jar file in the
	   lib directory.

	2. Say
		java net.grinder.Console

	3. Change to a test directory and set up a grinder.properties
	   file which defines the test you want to perform. See the
	   examples directory for inspiration.

	4. Say
		java net.grinder.Grinder

This starts an agent process that forks child Java processes to do the
work. You can also specify an explicit properties file as the first
argument. For example:

	java net.grinder.Grinder myproperties

For heavy duty testing, you can start an agent process on each of
several client machines. The child processes they launch can be
controlled and monitored using the Grinder Console. There is little
reason to run more than one agent on a single machine, but you can if
you wish.

The worker processes listen for Console signals on a multicast
address, by default this is 228.1.1.1:1235. Each worker process sets
up a TCP network connection to the Console to report statistics. By
default, the console listens on port 6372 on all local network
interfaces of the machine running the Console.

If the default mulicast addresses are not valid, alter following
properties before starting the Grinder agents

	grinder.consoleAddress	(Address of machine running Console)
	grinder.consolePort
	grinder.grinderAddress	(Multicast address)
	grinder.grinderPort

The Console does not read the grinder.properties file. It has its own
options dialog (choose the File/Options menu option), which you should
use to set the communication addresses and ports to match those in the
grinder.properties files.

When the child processes start, they inform the Console of the tests
they will run. If you start the Console after the Grinder processes,
you should press the "Reset processes" button. This will cause the
existing Grinder child processes to exit and the Grinder agent to
start new child processes, which will update the Console with the new
test information.


The output
**********

Each Grinder child process writes logging information to a file called
out-host-n.log, where host is hostname and n is the process number.
Errors will be written to error-host-n.log. If no errors occur, an
error file will not be created.

Data about individual test invocations is written into a file called
data-host-n.log. This can be imported into a spreadsheet tool such as
Microsoft Excel for further analysis.

The final statistics summary (in the out-* files of each process)
looks something like this:

 Final statistics for this process:

              Successful
              Transactions  Errors        Average (ms)  
Test 0        25            0             255.52        
Test 1        25            0             213.40        
Test 2        25            0             156.80         "Image"
Test 3        25            0             90.48         
Test 4        25            0             228.68         "Login page"
Test 5        25            0             86.12          "Security check"
Test 6        25            0             216.20        
Test 7        25            0             73.20         
Test 8        25            0             141.92        
Test 9        25            0             104.68         "Logout page"

Totals        250           0             156.70     


The Console gives a similar dynamic display of information collected
from all Grinder processes.


Each test has one of 2 possible outcomes:

	1. Success. The number of Successful Transactions for that test is
	   incremented The time taken to perform the test is added to
	   the Total.

	2. Error - "false" is returned from doTest(). The exact
	   interpretation of this depends on the plugin. The number of
	   Errors for the test is incremented.

The Total and Average figures are calculated based only on successful
transactions.


I don't get it, help!
*********************

Try asking at grinder-use@lists.sourceforge.net


What can I set in grinder.properties?
*************************************

Here's a minimal grinder.properties file that uses the HttpPlugin:

	grinder.plugin=net.grinder.plugin.http.HttpPlugin
	grinder.test0.parameter.url=http://localhost:80/index.html

If you start a Grinder process using this properties file it will
communicate with the Console using default addresses, use one child
process, one thread, and runs on cycle which contains once test. This
is not too much use, so read on... (and see doc/HTTPPlugin.txt).


    grinder.processes	-	The number of child processes to start.
				Default 1.

    grinder.threads	-	The number of threads that each 
				process spawns. Default 1.

    grinder.cycles	-	The number of cycles of the test script
				each thread performs. 0 means "run
				forever". Default 1.

    grinder.jvm		-	Use an alternate JVM for child processes.
				Defaults to "java" so you do not need
				to specify this if your path is
				sensible.

    grinder.jvm.classpath -	Use to adjust the classpath used for
				the child VMs. Anything specified here
				will be prepended to the classpath
				used to start the Grinder processes.

    grinder.jvm.arguments -	Additional arguments to child JVM's.


    grinder.logDirectory -	Directory to write log files to. Created
				if it doesn't already exist.

    grinder.appendLog	-	Append to, rather than overwrite,
				existing log files.

    grinder.hostID	-	Override the "host" string used in log
 				filenames and logs. Defaults to the
				host name.

    grinder.receiveConsoleSignals -
				Set to true to respond to Console
				signals. See "Tell me about the
				Console controls" below. Default true.

    grinder.reportToConsole -	Set to true to send statistics to the
				Console. Default true.

    grinder.consoleAddress -	The IP address or hostname to use
    				for communication from the Grinder
    				processes to the Console. Default is
    				all the network interfaces of the
    				console machine.

    grinder.consolePort -	The IP port to use for communication
				from the Grinder processes to the
				Console. Default is 6372.

    grinder.grinderAddress - 	The multicast address to use for
				communication between the Console and
				the Grinder processes and the Console.
				(See "What do I need to do to set up
				multicast?" below). Default 228.1.1.1.

    grinder.grinderPort -       The multicast port to use for communication
				from the Console to the Grinder processes.
				Default 1234.

    grinder.reportToConsole.interval -
				The period at which each process sends
				updates to the Console. This also
				controls the frequency at which the
				data files are flushed. Default 500
				ms.

    grinder.thread.initialSleepTime	-
				The maxmimum time in milliseconds that
				each thread waits before starting.
				Unlike the other sleep times, this is
				varied according to a flat random
				distribution. The actual sleep time
				will be a random value between 0 and
				the specified value. Affected by
				grinder.thread.sleepTimeFactor, but
				not grinder.thread.sleepTimeVariation.
				Default 0 ms.

    grinder.thread.sleepTime -	The time in milliseconds to wait
				between individual tests. Affected by
				both grinder.thread.sleepTimeFactor,
				and grinder.thread.sleepTimeVariation.
				Default 0 ms.

    grinder.thread.sleepTimeFactor -
				Apply a factor to all the sleep times
				you've specified. E.g., setting this
				to 0.1 would run the script ten times
				as fast. Default 1.

    grinder.thread.sleepTimeVariation -
				The Grinder varies the specified sleep
				times according to a Normal
				distribution. This property specifies
				a fractional range within which nearly
				all (99.75%) of the times will lie.
				E.g., if the sleep time is specified
				as 1000 and the sleepTimeVariation is
				set to 0.1, then 99.75% of the actual
				sleep times will be between 990 and
				1100 milliseconds. Default 0.2.

    grinder.plugin	-	The plugin class to use. Currently each
				script uses a single plugin.

    grinder.plugin.parameter -	Prefix for properties interpreted by
				the plugin. See the documentation for
				the HTTP plugin in doc directory for
				examples.

    grinder.test0	- 	Prefix for test 0 properties. Test 1 
				properties have a prefix of
				"grinder.test1", and so on. The
				tests are run in numerical order.

    grinder.test0.description -	Information string used in the log
			 	files and the Console.

    grinder.test0.sleepTime -	Override grinder.thread.sleepTime
				for a specific test.

    grinder.test0.parameter -	Prefix for test specific properties
			 	interpreted by the plugin. See the
			 	doc/HTTPPlugin.txt for examples.

    grinder.logProcessStreams - Set to false to disable the logging of
				output and error steams for Grinder
				child processes. You might want to use
				this to reduce the overhead of running
				a client thread. When recording
				timings with multiple clients it will
				probably reduce the measured time -
				see doc/Timing.txt. Default true.

    grinder.recordTime	   -	Set to false to disable reporting of
				timing information; other statistics
				are still reported. See
				doc/Timing.txt. Default true.

You should read the files doc/HTTPPlugin.txt and doc/JUnitPlugin.txt
for details on the properties for individual plugins.

The file doc/TCPSniffer.txt will tell you how to automatically record
a script for use with the HTTP plugin.


Tell me about the Console controls?
***********************************

The process controls:

  The controls "Start processes", "Reset processes" and "Stop
  processes" send signals to Grinder processes that are listening.
  (See the properties grinder.receiveConsoleSignals,
  grinder.grinderAddress and grinder.grinderPort.)

  Grinder child processes that are configured to receive console
  signals go through three states:

	1. Initiated (waiting for a console signal)
	2. Running   (performing tests, reporting to console)
	3. Finished  (waiting for a console signal)

  The "Start processes" button signals to child processes that they
  should move into the running state. Processes that are already
  running ignore this signal. Processes that are in the finished state
  exit; the agent process will then reread the properties file and
  launch new child processes in the running state.

  The "Reset processes" control signals all the child processes to
  exit. The agent process will then reread the properties file and
  launch new child processes.

  The "Stop processes" contol signals all processes to exit.

  *Warning* - unless grinder.appendLog is true, new child process logs
  will overwrite those from previous runs.

The sample controls:

  There are a set of controls that determine the samples that the
  Console will capture. It is important to understand that these
  sliders control the Console behaviour _only_. For example, they do
  not adjust the frequency at which the Grinder sends reports (see
  grinder.reportToConsole.interval for that). Additionally, they do
  not interact in any way with the process controls.

  The slider controls the period at which the console will take a
  "sample". This involves adding up all the reports recieved over that
  sample interval and calculating the TPS as (number of transactions
  that occured)/(interval length). It is also the period at which the
  Console graphs and statistics are updated.

  By default, the Console discards the first non-zero sample period,
  and starts updating the display and calcluating totals from the
  second sample. A non-zero sample period is one in which an update
  from a Grinder process was received. You can adjust how many
  non-zero sample periods the Console ignores before starting capture
  with the "ignore samples" text field.

  The third control allows you to adjust how many samples the Console
  will collect before stopping capture.

  You can also manually start and stop the sampling with the "Capture
  statistics"/"Stop capture" control. Use the "Save statistics"
  control to save the current set of statistics to a file.


Can I run different test scripts against the same Console?
**********************************************************

Yes.

The Console receives reports and updates the graph based on test
number. Thus it is possible to have different Grinder processes
running scripts with different test numbers (e.g. one process running
tests 1 to 5 and another running tests 6 to 10)., reporting to the
same Console.


What do I need to do to set up multicast?
*****************************************

You must set up multicast if you want to use the Console. It is used
to send signals from the Console to the Grinder processes (start,
stop).

Multicast addresses lie in the range 224.0.0.0 to 239.255.255.255.
Ports lie in the range 0 to 65535. The same multicast address is used
by The Grinder for commands from the Console to the grinder processes
(on the port specified by grinder.multicastPort) and for reports from
the grinder processes to the Console (on the port specified by
grinder.console.multicastPort).

You should ensure that the address and ports you chose does not clash
with other applications running on your LAN. The Grinder example files
uses the address 228.1.1.1 and the ports 1234 and 1235:

    grinder.receiveConsoleSignals=true
    grinder.grinderAddress=228.1.1.1
    grinder.grinderPort=1234


For most modern TCP stacks, e.g Windows 95/98/NT, Linux, multicast
works out of the box.

Under Linux, you may also need to set up the routing table. Try:

 $ route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0

Some Windows VPN clients (e.g Bay Networks Extranet) interfere with
multicast. You may need to disable them.

With a standalone Windows 2000 machine, you might experience similar
grief to myself. I found that I could only get multicast to work if my
LAN NIC had a carrier and the MS loopback adapter is not installed (or
disabled).

The following links contain experiences that tally with mine:

 http://www.web3d.org/WorkingGroups/vrtp/dis-java-vrml/hypermail/2001/0021.html
 http://www.web3d.org/WorkingGroups/vrtp/dis-java-vrml/hypermail/2001/0023.html
 http://www.web3d.org/WorkingGroups/vrtp/dis-java-vrml/hypermail/2001/0025.html

The last of these says:

	"I have been looking for a solution for this problem a long
	time without success :-( I found several dummy loopback IP
	stacks but none that supports multicast. The solution I have
	been using is to bring along a tiny hub and connect my laptop
	to that hub when doing demos. Windows is a bit stupid in the
	way that it only checks if it has a carrier."

I know of someone using a slightly cheaper/lighter solution; namely
crop a network cable short and twist your own physical loopback
adapter.

Needless to say, if anyone figures out how to get multicast working
with a standalone W2K machine, I'm more than interested.


How do I fix it?
****************

Please send bug fixes and enhancements you make to
grinder-development@lists.sourceforge.net.

BEA keeps me very busy so the timeliness and quality of any email
support I provide may vary.
