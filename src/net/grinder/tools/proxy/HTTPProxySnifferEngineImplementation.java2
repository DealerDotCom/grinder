// Copyright (C) 2000 Paco Gomez
// Copyright (C) 2000, 2001, 2002 Philip Aston
// Copyright (C) 2000, 2001 Phil Dawes
// Copyright (C) 2001 Paddy Spencer
// All rights reserved.
//
// This file is part of The Grinder software distribution. Refer to
// the file LICENSE which is part of The Grinder distribution for
// licensing details. The Grinder distribution is available on the
// Internet at http://grinder.sourceforge.net/
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
// OF THE POSSIBILITY OF SUCH DAMAGE.

package net.grinder.tools.proxy;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.net.Socket;

import org.apache.oro.text.regex.MalformedPatternException;
import org.apache.oro.text.regex.MatchResult;
import org.apache.oro.text.regex.Pattern;
import org.apache.oro.text.regex.PatternCompiler;
import org.apache.oro.text.regex.PatternMatcher;
import org.apache.oro.text.regex.Perl5Compiler;
import org.apache.oro.text.regex.Perl5Matcher;

import net.grinder.tools.tcpsniffer.ConnectionDetails;
import net.grinder.tools.tcpsniffer.SocketFactory;
import net.grinder.tools.tcpsniffer.SnifferEngineImplementation;
import net.grinder.tools.tcpsniffer.SnifferFilter;


/**
 * SnifferEngine that works as an HTTP proxy.
 *
 * @author Paddy Spencer
 * @author Philip Aston
 * @version $Revision$
 */
public class HttpProxySnifferEngineImplementation
    extends SnifferEngineImplementation
{
    private final PatternMatcher m_matcher = new Perl5Matcher();
    private final Pattern m_proxyConnectPattern;

    public HttpProxySnifferEngineImplementation(
	SocketFactory socketFactory,
	SnifferFilter requestFilter,
	SnifferFilter responseFilter,
	ConnectionDetails connectionDetails,
	boolean useColour,
	int timeout)
	throws IOException, MalformedPatternException
    {
	super(socketFactory, requestFilter, responseFilter, connectionDetails,
	      useColour, timeout);

	final PatternCompiler compiler = new Perl5Compiler();

 	m_proxyConnectPattern =
 	    compiler.compile(
 		"^([A-Z]+) http://([^/:]+):?(\\d*)/",
 		Perl5Compiler.MULTILINE_MASK | Perl5Compiler.READ_ONLY_MASK);
    }

    public void run()
    {
	// Should be more than adequate.
	final byte[] readAheadBuffer = new byte[4096];

	while (true) {
	    try {
		final Socket localSocket = getServerSocket().accept();

		// Grab the first upstream package and grep it for the
		// remote server and port in the method line.
		final BufferedInputStream in =
		    new BufferedInputStream(localSocket.getInputStream(),
					    readAheadBuffer.length);

		in.mark(readAheadBuffer.length);

		final int bytesRead =
		    in.read(readAheadBuffer, 0, readAheadBuffer.length);

		in.reset();

		final String line =
		    new String(readAheadBuffer, 0, bytesRead, "US-ASCII");

		if (m_matcher.contains(line, m_proxyConnectPattern)) {
		    final MatchResult match = m_matcher.getMatch();

		    final String remoteHost = match.group(2);

		    int remotePort = 80;

		    try {
			remotePort = Integer.parseInt(match.group(3));
		    }
		    catch (NumberFormatException e) {
			// remotePort = 80; 
		    }

		    final Socket remoteSocket =
			getSocketFactory().createClientSocket(remoteHost,
							      remotePort);

		    launchThreadPair(localSocket, remoteHost, remotePort);
		}
		else {
		    System.err.println(
			"Failed to determine proxy destination from message:");
		    System.err.println(line);
		}
	    }
	    catch(IOException e) {
		e.printStackTrace(System.err);
	    }
	}
    }
}
