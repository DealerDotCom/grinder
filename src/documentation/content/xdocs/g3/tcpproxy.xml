<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">

<document>
<header>
  <title>The TCPProxy</title>
</header>

<body>
  <p>The TCPProxy is a proxy process that you can place in a TCP
  stream, such as the HTTP connection between your browser and a
  server. It filters the request and response streams, sending the
  results to the terminal window (<code>stdout</code>). You can
  control its behaviour by specifying different filters.</p>

  <figure src="../images/tcpproxy.gif" width="762" height="340"
  alt="The TCPProxy"/>

  <p>The TCPProxy's main purpose is to automatically generate HTTP
  test scripts that can be replayed with The Grinder's HTTP plugin.
  Because the TCPProxy lets you see what's going on at a network level
  it is also very useful as a debugging tool in its own right.</p>

  <section>
    <title>Starting the TCPProxy</title>

    <p>You start the TCPProxy with something like:</p>

<source>
CLASSPATH=/opt/grinder/lib/grinder.jar
export CLASSPATH

java net.grinder.TCPProxy
</source>

    <p>Say <code>java net.grinder.TCPProxy -?</code> to get a full
    list of the command line options.</p>

    <p>With no additional options, the TCPProxy will start and display
    the following information:</p>

<source>
Initialising as an HTTP/HTTPS proxy with the parameters:
   Request filters:  EchoFilter
   Response filters: EchoFilter
   Local address:    localhost:8001
Engine initialised, listening on port 8001
</source>

    <p>This indicates that the TCPProxy is listening as an HTTP proxy
    on port <code>8001</code> (the default, but you can change it with
    <code>-localPort</code>). You must now set your browser connection
    settings to specify the TCPProxy as the HTTP proxy. In the browser
    options dialog, set the proxy host to be the host on which the
    TCPProxy is running and proxy port to be <code>8001</code>).</p>

    <figure src="../images/proxy-preferences.png" width="562"
    height="462" alt="Browser proxy preferences"/>

    <p>The TCPProxy appears to your browser just like any other HTTP
    proxy server, and you can use your browser as normal. If you type
    <code>http://grinder.sourceforge.net</code> into your browser it
    will display The Grinder home page and the TCPProxy will output
    all of the HTTP interactions between the browser and the
    SourceForge site.</p>

    <p>The TCPProxy will proxy both HTTP and HTTPS. See <a
    href="#ssl">below</a> for details on customising the SSL
    configuration.</p>

  <note><a href="site:mozilla">Firefox</a> users will find Jeremy
  Gillick's <em>SwitchProxy</em> extension useful for switching to and
  from the TCPProxy.</note>

  </section>

  <section id="EchoFilter">
    <title>Using the EchoFilter</title>

    <p>The EchoFilter outputs the stream activity to the terminal. It
    can be very useful for debugging as described in <a
    href="site:use-the-tcpproxy">this FAQ</a>.</p>

    <p>Bytes that do not have a printable ASCII representation are
    displayed in hexadecimal between square brackets. Here's some
    example output:</p>

    <source>
------ 127.0.0.1:2263->ads.osdn.com:80 ------
GET /?ad_id=5839&amp;alloc_id=12703&amp;site_id=2&amp;request_id=8320720&amp;1102173982760 HTTP/1.1
Host: ads.osdn.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0
Accept: image/png,*/*;q=0.5
Accept-Language: en-gb,en-us;q=0.7,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Proxy-Connection: keep-alive
Referer: http://sourceforge.net/projects/grinder


--- ads.osdn.com:80->127.0.0.1:2263 opened --
------ ads.osdn.com:80->127.0.0.1:2273 ------
HTTP/1.1 200 OK
Date: Sat, 04 Dec 2004 15:26:27 GMT
Server: Apache/1.3.29 (Unix) mod_gzip/1.3.26.1a mod_perl/1.29
Pragma: no-cache
Cache-control: private
Connection: close
Transfer-Encoding: chunked
Content-Type: image/gif


------ ads.osdn.com:80->127.0.0.1:2273 ------
80B
GIF89ae[00])[00D50000C3C3C3FEFDFD]hhhVVVyyy[F5CCD2D4D4D4CBCBCBD7]'F[A3A3A3DF]Og[F2BAC3DCDCDCABABABF7D4DAE6]x[8BFCF1F3DB]9U[EFA9B5FBE9ECF1F1F1F9F9F9B2B2B29C9C9CF3C3CBF5F5F5E5E5E5949494EB97A5070707]%%%[EA8D9DE0]Ul[EAEAEA838383F8DCE18C8C8CE0E0E0]===[E2]ez[D9D9D9B9B9B9EDEDED]JJJ[F0B3BDBEBEBE]AAA[F9E5E9]333[FDFAFBE88394F9E0[000000FFFFFF]![F9040000000000],[00000000]e[00])[000006FFC09E]pH,[1A8FC8A4]r[C9][D5B2]e[15]][E17F]+
    </source>

    <p>Information lines are displayed to indicate the end point
    addresses and direction of the information flow and also whether a
    has just been opened or closed.</p>

  </section>

  <section id="HTTPPluginTCPProxyFilter">
    <title>Using the HTTPPluginTCPProxyFilter</title>

    <p>You can use the TCPProxy to generate an HTTP plugin script
    suitable for use with The Grinder.</p>

<source>
java net.grinder.TCPProxy -httpplugin
</source>

    <p>The output of the HTTPPluginTCPProxyFilter looks like:</p>

<source>
Script will be generated to the files 'httpscript.py' and 'httpscript_tests.py'
Initialising as an HTTP/HTTPS proxy with the parameters:
   Request filters:  HTTPPluginTCPProxyFilter
   Response filters: HTTPPluginTCPProxyResponseFilter
   Local address:    localhost:8001
Engine initialised, listening on port 8001
</source>

    <p>The generated script is written to two files,
    <code>httpscript.py</code> and <code>httpscript_tests.py</code>.
    The <code>httpscript.py</code> file contains the high level flow
    of recorded tests. For example:</p>

<source>
# httpscript.py

from httpscript_tests import *

class TestRunner:
    def __call__(self):

        tests[0].GET('http://localhost:7001/')

        grinder.sleep(70)
        tests[1].GET('http://localhost:7001/index.jsp')

        grinder.sleep(100)
        tests[2].GET('http://localhost:7001/images/header_index.gif')

        grinder.sleep(190)
        tests[3].GET('http://localhost:7001/images/bullet.gif')

        tests[4].GET('http://localhost:7001/images/built_on_bea.gif')

        grinder.sleep(20)
        tests[5].GET('http://localhost:7001/images/transparent.gif')

        grinder.sleep(2564)
        tests[6].GET('http://localhost:7001/examplesWebApp/index.jsp')

        # ..
</source>

    <p>The details are kept in <code>httpscript_tests.py</code> so
    that the <code>httpscript.py</code> file is more readable:</p>

<source>
# httpscript_tests.py

from HTTPClient import NVPair
from net.grinder.plugin.http import HTTPRequest
from net.grinder.script import Test

tests = {}

headers0 = ( NVPair('Accept', 'image/gif, image/x-xbitmap, image/jpeg,
    image/pjpeg, application/vnd.ms-powerpoint, application/vnd.ms-excel,
    application/msword, application/x-shockwave-flash, */*'), 
            NVPair('Accept-Language', 'en-gb'), )
request0 = HTTPRequest(headers = headers0)
tests[0] = Test(0, 'GET ').wrap(request0)


request1 = HTTPRequest(headers = headers0)
tests[1] = Test(1, 'GET index.jsp').wrap(request1)

headers2 = ( NVPair('Accept', '*/*'), 
            NVPair('Accept-Language', 'en-gb'), 
            NVPair('If-Modified-Since', 'Thu, 17 Jul 2003 08:33:25 GMT'), 
            NVPair('Referer', 'http://localhost:7001/index.jsp'), )
request2 = HTTPRequest(headers = headers2)
tests[2] = Test(2, 'GET header_index.gif').wrap(request2)

request3 = HTTPRequest(headers = headers2)
tests[3] = Test(3, 'GET bullet.gif').wrap(request3)

# ...
</source>

    <p>Once you've recorded these files you just need to add a simple
    <a
    href="site:getting-started/properties"><code>grinder.properties</code></a>
    file and you can replay the recorded scenario with The Grinder.
    Your properties file should at least set <a
    href="site:getting-started/properties">grinder.script</a> to
    <code>httpscript.py</code>. The recorded scripts can be edited by
    hand to suit your needs.</p>

  </section>

  <section id="ssl">
    <title>SSL and HTTPS support</title>

    <p>The TCPProxy has SSL support based on the <a
    href="ext:javasoft/jsse">JSSE</a>. The JSSE is required by The
    Grinder, and is now part of Java 2 Standard Edition 1.4.1, see the
    <a href="site:download">Download page</a> for further details.</p>

    <p>SSL relationships are necessarily point to point. When you
    interpose the TCPProxy in SSL communications between a browser and
    a server you end up with two SSL connections. Each SSL connection
    has its own set of client and server certificates (both of which
    are optional).</p>

    <figure src="../images/tcpproxy-ssl.gif" width="762" height="200"
    alt="TCPProxy and SSL"/>

    <p>The TCPProxy will negotiate appropriate certificates for both
    connections using built-in certificates or in a user-specified
    Java key store. In particular, the TCPProxy needs a self-signed
    server certificate for the connection from the browser. By
    default, the TCPProxy will use a built-in certificate.</p>

    <p>When first establishing a connection, your browser will present
    a warning and confirmation dialog. This is because the built-in
    certficate isn't authorised by any of the certificate authorities
    that the browser trusts. Additionally the built-in certificate
    authorises <code>localhost</code>, so if your server doesn't
    listen at this address the browser will complain. Choose the
    "accept this certificate for this session" option.</p>

    <warning>The Grinder deliberately accelerates SSL initialisation
    by using a random number generator that is seeded with a fixed
    number. This does not hinder SSL communication, but theoretcially
    makes it less secure. No guarantee is made as to the
    cryptographical strength of any SSL communication using The
    Grinder.</warning>

    <p>Advanced users can specify their own server certificate for the
    connection from the browser, or add client certificates for the
    connection to the server, using the <code>-keystore</code>,
    <code>-keystorepassword</code>, and <code>-keystoretype</code>
    options. See the J2SE/JSSE documentation for how to set up a key
    store.</p>

    <p>If you fail to provide a key store with a valid server
    certificate (hard to do now The Grinder has a built in
    certificate), you may get a <em>No available certificate
    corresponds to the SSL cipher suites which are enabled</em>
    exception, and your browser may report that it cannot communicate
    as it has no common encryption algorithms. Internet Explorer likes
    to be different. If start the TCPProxy without a valid server
    certificate and then connect through it using Internet Explorer,
    the TCPProxy will report "SSL peer shut down incorrectly. The
    browser will just spin away until it times out. The easiest way to
    provide a server certificate is to copy the <em>testkeys</em> file
    from the <a href="ext:javasoft/jsse-samples">JSSE samples
    distribution</a> and start the proxy using:</p>

<source>
java net.grinder.TCPProxy -keyStore testkeys -keyStorePassword passphrase
</source>
  </section>

  <section id="chained-proxies">
    <title>Using the TCPProxy with other proxies</title>

    <p>The TCPProxy can be used with other HTTP/HTTPS proxies.</p>

    <figure src="../images/tcpproxy-proxy.gif" width="762"
    height="172" alt="Chained proxies"/>

    <p>Use the <code>-httpproxy</code> option to specify the host name
    and port of the proxy. Use the <code>-httpsproxy</code> option if
    your HTTPS proxy requires separate settings.</p>
  </section>

  <section id="port-forwarding-mode">
    <title>Using the TCPProxy as a port forwarder</title>

    <p>It is normally most useful to use the TCPProxy in its HTTP
    Proxy mode as described above.</p>

    <p>When using the TCPProxy as a debugging tool it occasionally is
    useful to use it in <em>port forwarding</em> mode. This mode is
    enabled when one or more of <code>-remotehost</code> and
    <code>-remoteport</code> are specified. In port forwarding mode,
    the TCPProxy simply listens on <code>localhost:localport</code>
    and forwards to <code>remotehost:remoteport</code>.</p>

    <p>To understand why HTTP Proxy mode is usually better than port
    forwarding mode when using a browser, consider what happens if the
    remote server returns a page with an absolute URL link back to
    itself. If you click on the link, the browser will contact the
    server directly, bypassing the TCPProxy. Another disadvantage is
    that you can't use the TCPProxy with more than one remote
    sever.</p>
  </section>

  <section id="options-summary">
    <title>Summary of TCPProxy options</title>

    <table>
    <tr>
      <th>Option</th>
      <th>Desciption</th>
    </tr>

    <tr>
      <td><code>-colour</code></td>

      <td>Specify that a simple colour scheme should be used to
      distinguish request streams from response schemes. This uses
      terminal control codes that only work on ANSI compliant
      terminals.</td>
    </tr>

    <tr>
      <td><code>-console</code></td>

      <td>Display a simple console that has a control button that
      allows The TCPProxy to be shutdown cleanly. This can help in
      certain situations where a hard kill of the TCPProxy process
      would loose output that is still buffered in memory .</td>
    </tr>

    <tr>
      <td><code>-httpplugin</code></td>

      <td>Add a request filter and a response filter to produce a
      script for The Grinder suitable for use with the HTTP
      plugin.</td>
    </tr>

    <tr>
      <td><code>-httpproxy host port</code></td>

      <td>Specify that output should be directed through <a
      href="#chained-proxies">another HTTP/HTTPS proxy</a>. This may
      help you reach the Internet. This option is not supported in <a
      href="#port-forwarding-mode">port forwarding mode</a>.</td>
    </tr>

    <tr>
      <td><code>-httpsproxy host port</code></td>

      <td>Specify that output should be directed through a HTTPS
      proxy. Overrides any <code>-httpproxy </code> setting. This
      option is not supported in <a href="#port-forwarding-mode">port
      forwarding mode</a>.</td>
    </tr>

    <tr>
      <td><code>-keystore file</code></td>

      <td>Specify a custom key store. Usually the built-in keystore is
      good enough so <code>-keystore</code> does not need to be
      specified.</td>
    </tr>

    <tr>
      <td><code>-keystorepassword password</code></td>

      <td>Set the key store password. Only used if
      <code>-keystore</code> is set. Optional for some key store
      types.</td>
    </tr>

    <tr>
      <td><code>-keystoretype type</code></td>

      <td>Set the key store type. Only used if <code>-keystore</code>
      is set. If not specified, the default value depends on JSSE
      configuration but is usually <code>jks</code>.</td>
    </tr>

    <tr>
      <td><code>-localhost host</code></td>

      <td>Set the host name or IP address to listen on. This must
      correspond to an interface of the machine the TCPProxy is
      started on. The default is <code>localhost</code>.</td>
    </tr>

    <tr>
      <td><code>-localport port</code></td>

      <td>Set the port to listen on. The default is
      <code>8001</code>.</td>
    </tr>

    <tr>
      <td><code>-properties file</code></td>

      <td>Specify a file containing properties that are passed on to
      the filters.</td>
    </tr>

    <tr>
      <td><code>-remotehost host</code></td>

      <td>Set the host name or port the TCPProxy should connect to in
      <a href="#port-forwarding-mode">port forwarding mode</a>. The
      TCPProxy starts in port forwarding mode if either
      <code>-remotehost</code> or <code>-remoteport</code> is set. The
      default is <code>localhost</code>.</td>
    </tr>

    <tr>
      <td><code>-remoteport port</code></td>

      <td>Set the port the TCPProxy should connect to in <a
      href="#port-forwarding-mode">port forwarding mode</a>. The
      TCPProxy starts in port forwarding mode if either
      <code>-remotehost</code> or <code>-remoteport</code> is set. The
      default is <code>7001</code>.</td>
    </tr>

    <tr>
      <td><code>-requestfilter filter</code></td>

      <td>Add a request filter. <code>filter</code> can be the name of
      a class that implements
      <code>net.grinder.tools.tcpproxy.TCPProxyFilter</code> or one of
      <code>NONE</code>, <code>ECHO</code>. The option can be
      specified multiple times, in which case the filters are invoked
      one after another. If the not specified, the default
      <code>ECHO</code> filter is used.</td>
    </tr>

    <tr>
      <td><code>-responsefilter filter</code></td>

      <td>Add a response filter. <code>filter</code> can be the name
      of a class that implements
      <code>net.grinder.tools.tcpproxy.TCPProxyFilter</code> or one of
      <code>NONE</code>, <code>ECHO</code>. The option can be
      specified multiple times, in which case the filters are invoked
      one after another. If the not specified, the default
      <code>ECHO</code> filter is used.</td>
    </tr>

    <tr>
      <td><code>-ssl</code></td>

      <td>Use SSL in <a href="#port-forwarding-mode">port forwarding
      mode</a>. This will make both the TCPProxy's local socket and
      the connections to the target server use SSL. The default
      <em>HTTP Proxy mode</em> ignores this option and always listens
      as an HTTP proxy and an HTTPS proxy.</td>
    </tr>

    <tr>
      <td><code>-timeout seconds</code></td>

      <td>Set an idle timeout. This is how long the TCPProxy will wait
      for a request before timing out and freeing the local port. The
      TCPProxy will not time out if there are active connections.</td>
    </tr>
    </table>
  </section>

</body>
</document>
